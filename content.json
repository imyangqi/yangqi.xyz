{"pages":[{"title":"","text":"关于光上帝说，要有光 $$ \\begin{aligned} \\nabla \\times \\mathbf{H}&=\\mathbf{J}_{\\mathrm{free}}+\\frac{\\partial \\mathbf{D}}{\\partial t} \\\\ \\nabla \\times \\mathbf{E}&=-\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\ \\nabla \\cdot \\mathbf{B}&=0 \\\\ \\nabla \\cdot \\mathbf{D}&=\\rho _{\\mathrm{free}} \\end{aligned} $$ 于是便有了光。这就是著名的麦克斯韦方程，光亦是一种电磁波。 关于我毕业于西安电子科技大学，电磁场与微波技术专业。 目前是一名电磁算法工程师，任职于某国产工业软件公司。 研究领域包括：电磁场时/频域算法(FDTD/DGTD/FEM)、高性能计算。","link":"/about/index.html"},{"title":"我的相册","text":"[2020年7月]硕士毕业留影","link":"/photos/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"我的简历","text":"杨琦 yanchio@163.com · imyangqi 教育经历 2017.08~2020.07，西安电子科技大学，硕士，专业：电磁场与微波技术荣誉：一等奖学金[2017/2019年]，优秀研究生[2018/2020年]，优秀学位论文提名奖[2020年] 2013.08~2017.07，西安电子科技大学，学士，专业：电子信息工程荣誉：国家励志奖学金[2016年] 竞赛经历 “华为杯”第15届中国研究生数学建模竞赛，一等奖（国家级），2018年10月，队长，负责建模与编程 为解决海洋潮汐潮流运动分析困难问题，构建了基于卫星高度计海面高度异常资料的潮汐调和分析模型，运用最小二乘和多项式拟合的方法分析了南海海域各主要分潮的调和常数，模型计算结果和验潮站实际测量数据吻合良好，可以为区域海洋潮汐的数值模拟工作提供重要的资料数据。 “美国大学生数学建模竞赛(ICM)，一等奖（国际级），2016年4月，队员，负责建模与编程 为解决当今世界上部分地区水资源短缺问题，运用模糊层次综合评价的理论建立了相应的地区水资源评价模型，然后预测了模型中的每个因子数据。根据影响因素与供需比的关系，预测了印度未来15年的用水情况，最后给出了政府干预的一些建议。 项目经历 研究课题：基于节点型间断伽辽金时域方法在电磁仿真中的应用，2018年10月~2020年2月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)该项目要求建立基于Maxwell方程和波动方程的不连续伽辽金时域算法的高性能电磁仿真平台。首先编程实现求解器的核心算法，内容包括Mesh文件处理、参数设置、模型求解、结果输出等基本功能，然后再通过OpenMP和MPI等技术将核心算法改写成并行架构以实现高性能的求解能力。本人主要负责的工作有：1、推导基于Maxwell方程的DGTD算法的主要核心公式和编程实现；2、推导在该框架下的波端口边界公式和编程实现；3、推导基于波动方程的节点型DGTD算法的核心公式并编程实现。 研究课题：基于波动方程的间断时域伽辽金方法的波端口建模，2017年8月~2018年9月开发工具：Visual Studio 2015(C++)、Salome(开源网格剖分软件)、ParaViS(数据可视化软件)传统实现波端口（Waveport）的方法是在端口截面使用总场/散射场的形式施加一个电流源或磁流源，然后在后端使用PML边界条件吸收电磁波，这种方法通常现需要额外的计算区域用于PML的建模。该项目的主要目的是通过使用一种精确的波端口边界吸收条件，将波端口面上的使用模式函数展开，再通过一种模式匹配的策略，使其不需要建模额外的计算区域也能精确得吸收反射的电磁波，从而能够精确计算S参数。 发表论文 [1] Q. Yang, Y. Shi, Z. G. Ban and S. C. Zhu, “A Nodal Discontinuous Galerkin Time-Domain Method Based on Wave Equation,” in IEEE Antennas and Wireless Propagation Letters, vol. 19, no. 7, pp. 1083-1087, July 2020, doi: 10.1109/LAWP.2020.2988916. [2] Q. Yang and Y. Shi, “Application of Nodal Discontinuous Galerkin Time Domain Method Based on Wave Equation in Electromagnetic Simulations,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), Xiamen, China, 2019, pp. 1075-1081, doi: 10.1109/PIERS-Fall48861.2019.9021891.Best Student Paper Award(Honorable Mention, PIERS2019 in Xiamen) [3]P. Wang, Y. Shi, Z. G. Ban, S. C. Zhu, Q. Yang and L. Li, “Penalty Factor Threshold and Time Step Bound Estimations for Discontinuous Galerkin Time-Domain Method Based on Helmholtz Equation,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 11, pp. 7494-7506, Nov. 2020, doi: 10.1109/TAP.2020.2998585. [4] Z. G. Ban, Y. Shi, Q. Yang, P. Wang, S. C. Zhu and L. Li, “GPU-Accelerated Hybrid Discontinuous Galerkin Time Domain Algorithm With Universal Matrices and Local Time Stepping Method,” in IEEE Transactions on Antennas and Propagation, vol. 68, no. 6, pp. 4738-4752, June 2020, doi: 10.1109/TAP.2020.2972404. [5] Y. Shi, P. Wang, Z. G. Ban, Q. Yang and S. C. Zhu, “Application of Hybridized Discontinuous Galerkin Time Domain Method into the Solution of Multiscale Electromagnetic Problems,” 2019 Photonics &amp; Electromagnetics Research Symposium - Fall (PIERS - Fall), 2019, pp. 2325-2329, doi: 10.1109/PIERS-Fall48861.2019.9021911. 技能清单 C++/Python/Matlab [●●●○○] 计算电磁学中的间断伽辽金时域方法 [●●●●○] 电磁场原理/天线原理/微波网络原理 [●●●●○] Latex/OriginLab/HFSS/CST/FEKO [●●●●○]","link":"/resume/index.html"}],"posts":[{"title":"C++中的std::bind用法总结","text":"前言std::bind包含在标准库头文件#include&lt;functional&gt;中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。 使用格式 std::bind使用的一般形式： 1auto new_fun = bind(fun, arg_list); 其中fun是一个函数，arg_list是用逗号隔开的参数列表。调用new_fun()相当于调用fun(arg_list)。 常见用法用法一：改变参数的个数头文件： 1234#include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; using namespace std::placeholders; 现在定义一个函数，接收一个数组array，数组长度n和某个数num，它将实现打印数组中大于num的功能 12345678auto fun = [](int *array, int n, int num){ for (int i = 0; i &lt; n; i++) { if (array[i] &gt; num) cout &lt;&lt; array[i] &lt;&lt; ends; } cout &lt;&lt; endl; }; 利用std::bind函数将原来函数调用所需要的参数固定为2个，实现过程如下： 123int array[] = { 1, 3, 5, 7, 9 }; auto new_fun = bind(fun, _1, _2, 5); //_1，_2是占位符，固定num=5 new_fun(array, sizeof(array) / sizeof(*array)); // 调用只需要2个参数了 上面代码中_1，_2是占位符，定义于命名空间placeholders中，_1是nnew_fun的第一个参数，_2是new_fun的第二个参数，以此类推。在本例中，fun()的调用需要传递三个参数，而用bind()进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是bind最常见的用法。 用法二：更改参数的顺序 bind的另一个常见的用法是更改参数的调用顺序，如 12int fun(int a, int b);auto new_fun = bind(fun, _2, _1); 此时，调用new_fun(1, 2)相当于调用fun(2, 1)。","link":"/2021/04/28/210428_cpp_std_bind/"},{"title":"C++中的std::function用法总结","text":"关于标准库中的std::function类模板，在cppreference官方给出的解释是 Class template std::function is a general-purpose polymorphic function wrapper. Instances of std::function can store, copy, and invoke any CopyConstructible Callable target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members. 中文的意思是：类模板std::function是一种通用的多态函数封装，std::function的实例可以对任何CopyConstructible Callable目标进行存储、复制和调用操作，这些目标可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。std::function对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。 比较通俗的理解就是，通过std::function对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的std::function对象，让我们不需要再纠结那么多的可调用实体。 对函数的封装定义一个实现加法的函数 1234double add(double a, double b){ return a + b;} 我们可以将其封装为一个function类 1std::function&lt;double(double, double)&gt; f_add = add; 用下面的方式对f_add实体对象进行调用 1auto result = f_add(4,5); // 结果将返回9 对函数类/结构体的封装定义一个除法的结构体或者类 1234567struct my_div{ double operator()(double a, double b) { return a / b; }}; 将其封装为一个function对象 1std::function&lt;double(double, double)&gt; f_div = my_div(); 同样的，调用形式和上面的f_add一样 1auto result = f_div(6, 2); // 执行完result结果为3 对Lambda表达式的封装Lambda表达式Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。 Lambda表达式的完整声明为： 1[capture list] (params list) mutable exception-&gt; return type { function body } 各项具体含义如下 capture list：捕获外部变量列表 params list：形参列表 mutable指示符：用来说用是否可以修改捕获的变量 exception：异常设定 return type：返回类型 function body：函数体 我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下 123456// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。[capture list] (params list) -&gt; return type {function body}// 省略了返回值类型，编译器可以自动推断。[capture list] (params list) {function body}// 省略了参数列表，类似普通函数中的无参函数。[capture list] {function body} 让我们来看个例子，现在假设我们有一个无序的vector变量，我们想用C++标准库中的sort函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数 1234bool cmp(int a, int b){ return a &lt; b;} 调用sort函数，旧式的做法如下 1sort(myvec.begin(), myvec.end(), cmp);// myvec是一个int类型的无序变量 现在可以方便地利用Lambda表达式来简化代码 1sort(myvec.begin(), myvec.end(),[](int a, int b)-&gt;bool {return a &lt; b;}); 值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种： 捕获形式 说明 [] 不捕获任何外部变量 [x, y…] 默认以值的形式捕获指定的多个外部变量（用逗号分隔） [this] 以值的形式捕获this指针 [=] 以值的形式捕获所有外部变量 [&amp;] 以引用形式捕获所有外部变量 [=, &amp;x] 变量x以引用形式捕获，其余变量以传值形式捕获 [&amp;, x] 变量x以值的形式捕获，其余变量以引用形式捕获 如果我们需要修改捕获变量，这时需要利用mutable关键字 12int a = 100;auto f = [a]()mutable { cout &lt;&lt; ++a; }; // 执行完后a=101 封装Lambda表达式现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为 1std::function&lt;double(double, double)&gt; f_mul = [](double x, double y) { return x * y; }; 将函数作为参数很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用std::function实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。 1234double calculator(double a, double b, std::function&lt;double(double, double)&gt; fn){ return fn(a, b);} 我们将上面已经定义的f_add对象作为参数传入calculator()函数中，在内部进行调用 1auto res = calculator(4, 5, f_add); 这样我们就实现了函数的回调。 总结通过以上的例子，我们学会了如何使用标准库中的std::function模板类对函数对象进行封装，从而可以统一成一种形式的调用，在最后我们还学习了如何将std::function类作为函数的参数，来实现回调函数的功能。","link":"/2021/04/28/210428_cpp_std_function/"},{"title":"《少年维特的烦恼》读书笔记","text":"五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。 故事中维特为了逃避世事的纷扰，只身来到瓦尔海姆。在一次去乡村舞会的路上，他结识了天使般美丽纯洁的少女夏绿蒂，并对她一见倾心，陷入爱河。这时的绿蒂已经和一个名叫阿尔伯特的人订了婚，阿尔伯特为人正直、诚实、可靠，就连绿蒂也认为：阿尔伯特的“稳重可靠仿佛天生可以作为一种基础，好让一个贤淑的女子在上面建立幸福的生活”。面对看起来如此般配的一对人，维特对绿蒂的爱情烈火并没有就此熄灭，而是越来越旺，维特几乎不能自己。一面是自己深爱的女子，一面是对自己友善的阿尔伯特——她的未婚夫，在三个人的爱情角逐中，维特经过矛盾和痛苦挣扎后不得不忍痛退出，去了一家很远的公使馆担任书记官，然而这里的生活并不如意，他常常郁郁寡欢，彷徨苦闷。最后他又回到了绿蒂身边，这时的绿蒂已经和阿尔伯特结婚，婚后的生活并不愉快。失去维特后，绿蒂的内心空虚寂寥，和维特的久别重逢，使他们再一次陷入爱情的深潭，不可自拔。维特对绿蒂的爱之深切与不能得到绿蒂的矛盾，又使他陷入绝望的境地，极度痛苦的维特最后举枪自杀。 对于维特最后的选择令我感到心痛，但又理解他的选择。美剧《无耻之徒》里面有一句台词： Love is not supposed to be cute, love is raw and destructive.爱从来都不是什么可爱的东西，爱是生猛而具有毁灭性的。 维特曾是那么地热爱着自然： 每当我周围的可爱峡谷霞气蒸腾，杲杲的太阳悬挂在林梢，将它的光芒这儿那儿地偷射进幽暗密林的圣地中来时，我便躺卧在飞泉侧畔的茂草里，紧贴地面观察那千百种小草，感觉到叶茎间有个扰攘的小小世界——这数不尽也说不清的形形色色的小虫子、小蛾子——离我的心更近了，于是我感受到按自身模样创造我们的全能的上帝存在，感受到将我们托付于永痕欢乐海洋之中的博爱天父的嘘息。——五月十日 和那么地喜欢着孩子们： 是的，威廉，在这个世界上离我的心最近的是孩子们。每当我从旁边观察他们，从细小的事情中发现他们有朝一日所需要的种种品德与才能的萌芽，从他们今日的固执任性中看出将来的坚毅与刚强，从今日的顽皮放肆中看出将来的幽默乐观以及轻松愉快地应付人世危难的本领，每当我发现这一切还丝毫未经败坏，完整无损，我便一次一次地，反反复复地，吟味人类的导师[1]这句金言。——六月二十九日 注释：[1]指耶稣。事见《圣经·新约·马太福音》第十八章：耶稣对门徒说：”你们若不回转，变成小孩子的样子，断不得进天国。“ 每当我在书中读到维特在自然界中感受到美妙之处，以及和孩子们相处时的快乐，便会联想到自己也是那么地喜欢着大自然和孩子们，很多次走在家乡的田野里，小河边，独自寻觅着路边的野花，静静地聆听潺潺的水流声，和孩子们一起分享食物，教他们使用电脑，给他们布置玩耍的场地，从他们的热情和善良中感受到这个世界的可爱。 歌德完成这部作品前后只花了四周的时间，之所以能如此高效是因为这部作品中的大部分内容都来自歌德自身的经历。1772年5月，歌德遵循父命到威茨拉尔的帝国高等法院实习。威茨拉尔是座空气陈腐得令人窒息的小城，帝国法院更以办事拖沓而恶名远播。歌德因此把实习的事情抛到脑后，终日悠游于景色宜人的乡间，在那儿研读荷马、品达等人的作品，做他感兴趣的事情。6月9日，在一次乡村舞会上，他结识了天真美丽的少女夏绿蒂·布甫，对她产生了热烈的爱慕。但夏绿蒂已经订婚。尽管她的未婚夫科斯特纳和夏绿蒂一家对歌德都十分友善，但他仍因失恋而感到痛苦，终于在9月11日不辞而别，回到法兰克福。 回到故乡以后，歌德久久未能克服心头的苦闷，以致产生了自杀的念头。谁料差不多就在这个时候，另一个人却把他几经尝试而放弃的事情完成了，一个他认识的叫耶鲁撒冷的青年自杀了。出事地点也正好在威茨拉尔，歌德在散步时还常常与他相遇。而且自杀的主要原因也同为恋慕他人之妻遭到拒斥。这种种情况，不能不令歌德联想到自身的遭遇，对同病相怜的耶鲁撒冷的不幸感到切肤之痛。 再后来，1774年初，女作家索菲的女儿玛克西米莲娜嫁给了一个名叫勃伦塔诺的富商，移居到了法兰克福。前年，歌德从威茨拉尔返回故乡时，曾顺便访问她家，对她颇有好感。如今重逢，两人都甚为欣喜。可惜这幸福很快变成了新的痛苦源泉，勃伦塔诺比玛克西米莲娜大二十岁，已经时有五个孩子的鳏夫，除去做生意赚钱别无所长，性情急躁而好嫉妒，很快对两个年轻人的交往产生疑忌，以致和歌德产生激烈冲突。这新的痛苦狠狠触动了歌德心灵中旧有的创伤，使他感到更加痛苦。为了彻底医治好自己的伤痛，歌德便愤而提笔，开始了维特的写作。 年轻的歌德完全进入了创作的狂热和忘我地境地，就像个梦游者似的，在几乎是无意识的状态下写成了这本小册子，以致当他最后拿起手稿来进行修改润饰时，自己也感到十分惊讶。维特一书之所以能如此情真意切，感人肺腑，这都是因为歌德的亲身感受。 在信息发达的现代社会，经常能看见新闻有人因为各种原因而结束自己的生命，有时候很难去体会当事者要经历多大的痛苦，才会选择直面死亡，以死亡来结束掉这一切。我知道，这种决定并不是一瞬间完成的，而是从出生到当下的一种经历的积分式结果。我不会也没有权力去指责他人的决定，但我仍会感到惋惜，或许只要再等一等，就能体会到这个世界的一点点美好之处，而放弃结束生命的念头。 生命的意义是什么？我时常思考这个问题，但每个阶段得到的答案都不尽相同。现在的我觉得生命的意义在于爱，这种爱是对世间万物的爱，对他人的爱。一个人如果只考虑自身的利益，会很容易让自己陷入到一种狭隘的境地，无法去体会世界的美好和可爱之处。我们要去爱他人，去帮助他人，在爱人的过程中感受到被爱，从而建立人与人之间的羁绊。维系着我们生活下去的，正是这一份一份的羁绊。","link":"/2021/05/05/210505_The_Sorrows_of_Young_Werther/"},{"title":"光生写给结夏的信","text":"最近看完了日剧《最完美的离婚》，没想到在特别篇的结尾，光生和结夏还是分手了。 很久之后，光生写下了这样一封信给结夏。看完信被深切感动到了。 星野结夏小姐： 春寒料峭，你是否安好？没有感冒吧？没有长冻疮吧？对不起，突然给你写信。如果能承蒙你在寒夜中雅鉴，不胜荣幸。 首先，向你报告，在我们家即将迎来第三个年头的两只猫的情况。不知为何，它们最近经常看电视，边看股票的新闻边交谈。对它们的人生来说，股票有什么作用呢？ 金鱼咖啡，因为姐姐要调养身体，最近继男姐夫在画咖啡拉花，画风独辟蹊径，经常有女性客人失望而归。 经由上原先生介绍，前几天终于见到了河合先生。我很震惊，河合先生是位希腊雕像一样的大帅哥。他伸手同我握手，说，“初次见面”，不知道能不能和他成为朋友。 在目黑川来来往往的人们，抬头看着樱花树，期待着开花时节，已经互相定下了赏花的约定，那个热闹的季节又要到来了。 昨天我梦到你了，梦见你抱着好多气球。你把无数个气球系在我和你的身上，我和你被气球带起，飞上了天空。俯瞰着目黑川，发现玛蒂尔达和八朔在抬头看着我们，上原夫妇抱着小婴儿朝我们招手。我只能被气球带着，随风飘荡，对自己的无力有点悲伤。 我现在依然每天会走过岸边的街道，不可思议的是，并不觉得自己是一个人。我依然每天都同你的记忆一起生活着。你经常在浴室里唱的歌，“静静地，静静地，握起你的手，握起你的手”，这样开头的歌，这样的场景。 想起深夜两个人出门借DVD的那一次，我和你注意到月亮已经变得好大，一时忘了出门的理由，在夜色中散起步来。在旧山手路买了烤红薯，掰成两半之后，发现大小相差悬殊，于是猜拳决定。吃着红薯，笑着，牵着手。我说要结婚，你的嘴巴被红薯塞得满满囔囔的，含糊不清地回答了我，这样的开始，这样的场景。 和你结婚后，我懂得了很多事。洗手台上并排着的牙刷，被窝中碰到的脚，不知何时消失掉的冰箱中的布丁，先下楼梯，和在你的后面上楼梯……恋爱总有一天会变成生活，生活会变成喜悦。穿错了女生袜子出门，发邮件来拜托我录的电视节目，抓背，做噩梦了就互相依偎，另一位父亲，另一位母亲，另一个家乡，家乡寄来的装在蜜柑箱子里的白菜，由生活演奏的音乐，在生活中互相传达的故事……这里还四处散落着，房间的角落里，电灯泡的里面，窗帘的缝隙里，还同以前一样留着。我如今也每天感受着从过去而来的你所留下的爱情。 我今天也会走过河边的街道，各自拥有的两个人一起生活过的回忆，住在我心中的你，闯进你世界的我，不可思议的，并不觉得变成了一个人。总有一天会觉得这样的想法太过愚蠢，却还是这样想着，在夜色中散步，猜拳决定，吃着烤红薯，笑着，牵着手，吃着满口的烤红薯，再说起同样的话。 我们在一起的话会很开心吧？一起慢慢变老吧？可以嫁给我吗？ 2014年2月8日 我在目黑川岸边的旧公寓，和两只猫一起，等待着春天的来临。 日文原文： 星野 結夏さま： 暦（こよみ）の上に春は立ちながら厳しい寒さが続いておりますがいかがお過ごしですか？風邪などひいていませんか？霜焼（しもや）けなどしていませんか？突然の手紙ごめんなさい。まだまだ寒く長い夜のついでに目を通していただければ幸（さいわ）いです。 まずわが家に暮らして３年目を迎える２匹（ひき）の猫に関してお知らせします。彼らはなぜか最近テレビをよく見ます。株価のニュースを見ながら話をしています。彼らの人生に株価が何か作用（さよう）することがあるのでしょうか？ 金魚（きんぎょ）カフェでは姉の体調もあって最近継男（つぐお）さんがラテアートを描（か）いています。その絵の作風（さくふう）が常軌（じょうき）を逸（いっ）しており女性客が悲鳴（ひめい）を上げて帰ることしばしばです。 上原さんに紹介されて先日ついに河合さんと対面しました。驚きです。河合さんはまるでギリシャ彫刻（ちょうこく）のような二枚目だったのです。握手の手を差し伸べ「やあ、初めまして」とおっしゃっていました。友達になれるかどうかはちょっと分かりません。 目黒川を行き交（か）う人々は桜の木を見上げて開花（かいか）の時季（じき）を待ちわびながら、すでに花見の約束を取り交わしています。また、あのにぎやかな季節が訪（おとず）れるのですね！ 昨日、君の夢を見ました。君がたくさんの風船（ふうせん）を抱（かか）えてくる夢でした。君は無数（むすう）の風船を僕と自分の体に結（むす）び付けました。僕と君は風船に軽く体を持ち上げられて空を飛びました。目黒川を見下ろすとマチルダとはっさくが見上げてるのが見えました。上原さんたちが赤ん坊を抱いて手を振っていました。僕は風に流されて飛んでいくしかない、自分の非力さが少し悲しかったです。 川沿（ぞ）いの道を今日も歩きます。不思議と一人になった気がしません。まだまだ僕は毎日を君の記憶と共に暮らしています。君がよくお風呂場で歌っていた歌、「静かに 静かに 手を取り 手を取り」、そんなふうに始まる歌、そんな光景。 深夜二人でDVDを借りに出掛けたときのこと、月がずいぶんと大きなことに気がついた僕と君は、そもそもなぜ出掛けたのかさえ忘れて、夜中の散歩をしました。旧山手通りで焼き芋（いも）を買って、半分に割ったら大きさがまるで違って、じゃんけんして食べて、笑って、手をつないで、僕が結婚を口にしたら、君は焼き芋いっぱい頬張（ほおば）った口で声にならない返事をしました。そんな始まり、そんな光景。 君と結婚して知ったことがあります。洗面台（せんめんだい）に並んだ歯ブラシ、ベッドの中でぶつかる足、いつの間にか消えてる冷蔵庫のプリン、階段を先に下りること、階段を後から上がること、恋がいつしか日常に変わること、日常が喜びに変わること、間違えてはいて出掛けた女物の靴下、メールで頼まれる番組録画（ろくが）、背中をかくこと、怖い夢を見たら寄り添（そ）うこと、もう一人の父親、もう一人の母親、もう一つの古里、古里から届くミカン箱の中のハクサイ、日常が奏（かな）でる音楽、日常を伝え合うことの物語（ものがたり）．．．ここにはまだそれが転がっています。部屋の隅に電球の裏にカーテンの隙間（すきま）にくっついたまま。僕は今も毎日のように過去から訪れる君の愛情を受け取っています。 川沿いの道を今日も歩きます。一人ずつ二人で生きていたこと、僕の中に住んでいる君、君の中に迷い込んだ僕、不思議と一人になった気がしません。いつかまたそう思うことの愚（おろ）かさを思いながらそれでも思います。夜中の散歩をして、じゃんけんして、食べて、笑って、手をつないで、焼き芋頬張りながら、また同じことを話すんです。 僕たち一緒にいると、楽しいよね？一緒に年を取りませんか？結婚してくれませんか？ ２０１４年２月８日 目黒川沿いの古いマンションで２匹の猫と共に春の訪れを待っています。","link":"/2021/05/20/210520_letter_guangsheng_to_jiexia/"},{"title":"微波网络中的分贝值","text":"前言当我们在仿真天线或者一些微波器件的时候，S参数是很重要的参数之一，关于S参数的定义在很多微波工程中的书都能找到，但是对于具体如何计算，却很少有教科书会提及，这些概念大多散落在CEM领域的一些专业论文里面。本文旨在介绍几种常用激励端口下的S参数提取。 关于分贝值(dB)通常我们在商业软件中计算出来的S参数都是用dB值来表示，这是由于在微波系统中两功率电平P1和P2之比经常用分贝(dB)来表示，即 $$ 10\\log _{10}\\frac{P_1}{P_2}\\mathrm{dB} $$ 不难发现用这种定义方法后，当功率之比为2时等效为3dB，功率比为0.1时等效为-10dB。这使得在计算元器件之前的功率损耗和增益中变得容易，因为相乘的损耗或增益因子可以通过对每一级用分贝表示的损耗或增益的相加来计算。例如，当一个信号经过一个6dB的衰减器和一个23dB的放大器之后，将具有23-6=17dB的总增益。 值得注意的是，在微波网络中分贝值只表示为功率比，但有时候也可以用电压来表示功率比，由于 \\( P_1=V_{1}^{2}R_1\\) 和\\(P_2=V_{2}^{2}R_2\\)，因此有 $$ 10\\log _{10}\\frac{V_{1}^{2}R_2}{V_{2}^{2}R_1}=20\\log \\frac{V_1}{V_2}\\sqrt{\\frac{R_2}{R_1}}\\mathrm{dB} $$ 其中，\\(R_1\\)和\\(R_2\\)为负载电阻，\\(V_1\\)和\\(V_2\\)为负载电压，如果负载电阻相等，那么公式可以简化为 $$ 20\\log \\frac{V_1}{V_2}\\mathrm{dB} $$","link":"/2021/07/18/210718_em_power_dB/"},{"title":"连续&#x2F;离散周期信号的傅里叶变换","text":"在信号处理中，傅里叶变换是必不可缺的一部分，而傅里叶变换又分为连续和非连续信号的傅里叶变换，现就这一系列的知识作一个总结和归纳。 连续时间周期信号的傅里叶级数表示成谐波关系的复指数信号集如果一个信号是周期的，那么对于所有的\\(t\\)，存在某个正值的\\(T\\)，有： $$ x\\left( t \\right) =x\\left( t+T \\right) $$ \\(x\\left(t\\right)\\)的基波周期就是满足上式的最小非零正值\\(T\\)，\\(\\omega _0=2\\pi /T\\)称为基波频率。例如周期复指数信号 $$ x\\left( t \\right) =e^{j\\omega _0t} $$ 与其有关的成谐波关系的复指数信号集就是 $$ \\phi _k\\left( t \\right) =e^{jk\\omega _0t}=e^{jk\\left( 2\\pi /T \\right) t}, k=0,\\pm 1,\\pm 2,... $$ 这些信号中的每一个都有一个基波频率，是\\(\\omega_0\\)的倍数，因此每一个信号对于周期\\(T\\)来说都是周期的。于是，一个由成谐波关系的复指数线性组合形成的信号 $$ x\\left( t \\right) =\\sum_{k=-\\infty}^{+\\infty}{a_ke^{jk\\omega _0t}}=\\sum_{k=-\\infty}^{+\\infty}{a_ke^{jk\\left( 2\\pi /T \\right) t}} $$ 对\\(T\\)来说也是周期的，上式中，\\(k=0\\)这一项是常数，\\(k=+1\\)和\\(k=-1\\)这两项都有基波频率等于\\(\\omega_0\\)，两者结合在一起称之为基波分量，或者一次谐波分量。\\(k=+2\\)和\\(k=-2\\)这两项也是周期的，周期为基波分量周期的1/2，称之为二次谐波分量，依此类推。一个周期信号表示成上式，就称之为该式的傅里叶级数表示。 傅里叶级数表示的确定现在假设一个给定的周期信号能表示成傅里叶级数的形式，那就需要一种方法来确定这些系数\\(a_k\\)。推导过程很简单，将上面的式子两边各乘以\\(e^{-jn\\omega _0t}\\)并在\\(0\\)到\\(T=2\\pi /\\omega _0\\)上对\\(t\\)积分即可，有： $$ \\int_0^T{x\\left( t \\right) e^{-jn\\omega _0t}dt}=\\int_0^T{\\sum_{k=-\\infty}^{+\\infty}{a_ke^{jk\\omega _0t}e^{-jn\\omega _0t}}dt} \\\\ =\\sum_{k=-\\infty}^{+\\infty}{a_k\\left[ \\int_0^T{e^{j\\left( k-n \\right) \\omega _0t}dt} \\right]} $$ 上式右边括号的积分结果利用欧拉关系很容易得到 $$ \\int_0^T{e^{j\\left( k-n \\right) \\omega _0t}dt}=\\begin{cases} T, k=n\\\\ 0, k\\ne n\\\\ \\end{cases} $$ 因此，右边的式子就简化为\\(Ta_n\\)，所以 $$ a_n=\\frac{1}{T}\\int_0^T{x\\left( t \\right) e^{-jn\\omega _0t}dt} $$ 至此，周期函数的傅里叶级数展开的系数就确定了。另外，由于积分是在\\(T\\)的时间间隔内进行的，而\\(T\\)又是\\(\\cos \\left( k-n \\right) \\omega _0t\\)和\\(\\sin \\left( k-n \\right) \\omega _0t\\)周期的整数倍，所以在任意\\(T\\)的间隔做积分，结果都是相同的。 上述过程可以归纳如下：如果\\(x\\left( t \\right)\\)有一个傅里叶级数表示式，那么傅里叶级数中的系数可以确定为 $$ x\\left( t \\right) =\\sum_{k=-\\infty}^{+\\infty}{a_ke^{jk\\omega _0t}}=\\sum_{k=-\\infty}^{+\\infty}{a_ke^{jk\\left( 2\\pi /T \\right) t}} \\\\ a_k=\\frac{1}{T}\\int_T{x\\left( t \\right) e^{-jk\\omega _0t}dt}=\\frac{1}{T}\\int_T{x\\left( t \\right) e^{-jk\\left( 2\\pi /T \\right) t}dt} $$ 离散时间周期信号的傅里叶级数表示成谐波关系的复指数信号集对于一个离散信号\\(x[n]\\)，若有 $$ x\\left[ n \\right] =x\\left[ n+N \\right] $$ 就是一个周期为\\(N\\)的周期信号。基波周期就是\\(N\\)，基波频率为\\(\\omega _0=2\\pi /N\\)。例如，复指数\\(e^{jk\\left( 2\\pi /N \\right) n}\\)就是周期的，再者，有下式给出的 $$ \\phi _k\\left[ n \\right] =e^{jk\\omega _0n}=e^{jk\\left( 2\\pi /N \\right) n},k=0,\\pm 1,\\pm 2,... $$ 所有离散时间复指数信号集合都是周期的，且周期为\\(N\\)。\\(\\phi _k\\left[ n \\right]\\)中的全部信号，其基波频率都是\\(2\\pi /N\\)的整数倍，因此它们之间互为谐波关系。由于上式中的信号集只有\\(N\\)个信号是不相同的，因此不难得出 $$ \\phi _k\\left[ n \\right] =\\phi _{k+rN}\\left[ n \\right] $$ 现在我们希望利用序列\\(\\phi _k\\left[ n \\right]\\)的线性组合来表示更为一般的周期序列，即 $$ x\\left[ n \\right] =\\sum_k{a_k\\phi _k\\left[ n \\right]}=\\sum_k{a_ke^{jk\\omega _0n}}=\\sum_k{a_ke^{jk\\left( 2\\pi /N \\right) n}} $$ 因为序列\\(\\phi _k\\left[ n \\right]\\)只在\\(k\\)的\\(N\\)个相继值的区间上是不同的，因此上式求和仅仅需要包含\\(N\\)项即可，于是上式的求和可以写成 $$ x\\left[ n \\right] =\\sum_{k=\\left< N \\right>}{a_k\\phi _k\\left[ n \\right]}=\\sum_{k=\\left< N \\right>}{a_ke^{jk\\omega _0n}}=\\sum_{k=\\left< N \\right>}{a_ke^{jk\\left( 2\\pi /N \\right) n}} $$ 上式称之为离散时间傅里叶级数，而系数\\(a_k\\)称之为傅里叶级数系数。 傅里叶级数表示的确定推导过程省去，直接给出离散时间傅里叶级数对，为 $$ x\\left[ n \\right] =\\sum_{k=\\left< N \\right>}{a_ke^{jk\\omega _0n}}=\\sum_{k=\\left< N \\right>}{a_ke^{jk\\left( 2\\pi /N \\right) n}} \\\\ a_k=\\frac{1}{N}\\sum_{n=\\left< N \\right>}{x\\left[ n \\right] e^{-jk\\omega _0n}}=\\frac{1}{N}\\sum_{n=\\left< N \\right>}{x\\left[ n \\right] e^{-jk\\left( 2\\pi /N \\right) n}} $$ 上面的两个表明了，如果一个离散的周期信号展开为傅里叶级数的求法，第一个公式称之为综合公式，第二个称之为分析公式。和连续时间信号情况一样，离散时间傅里叶级数系数\\(a_k\\)也往往称之为\\(x\\left[ n \\right] \\)的频谱系数。","link":"/2021/07/25/210725_DTFT_and_FFT/"},{"title":"猎户座LL星的弓形激波","text":"前言在NASA官网有一个入口，可以查看在你生日的那一天，哈勃望远镜在太空中看到了什么，网站支持输入月份和日数，所查询出来的结果是某一年份下你生日那天哈勃在太空所看到的景象，可以把它当成是给自己的一份生日礼物，觉得这是件非常浪漫的事。我输入了自己的生日2月3日（阳历），看到刚好在我出生的那一天，哈勃在太空中看到了猎户座LL星的弓形激波。 猎户座LL星的弓形激波 这道优雅庞大的弧状结构，实际上是个宽度约半光年的弓形激波，因年轻猎户座LL星的恒星风冲撞猎户座星云的云气流而形成的。漂流在猎户座恒星育婴室内的猎户座LL星，是一颗还处在诞生阶段的变星，它发出比我们中年太阳还要强烈的恒星风。当高速的恒星风冲击慢速移动的云气时，就会产生一道激波前缘，酷似船滑过水面的船首波或以超音速飞行的飞机所造成之弓形波。此区域慢速云气流的推手，是猎户座星云中心、位在此影像右下缘外头的炽热四合星群。如果在三维空间去看猎户座LL星的反折激波，形状会像是一个碗，而从底部往上看时最为明亮。猎户座的众多恒星诞生区里，有各式各样与恒星形成相关的流形，包括影像右上角一颗暗星周围的弓形激波。上面这幅由哈伯太空望远镜摄于1995年的彩色组合影像，是猎户座大星云马赛克影像的一部份。","link":"/2021/11/03/211103_LL_Oriniors/"},{"title":"四面体上的高斯积分","text":"问题描述设\\(f_1\\left( \\boldsymbol{x} \\right) \\)和\\(f_2\\left( \\boldsymbol{x} \\right) \\)分别为定义在两个相邻四面体内的函数，其表达式为： $$ f_1\\left(\\boldsymbol{x} \\right) =2x+4y+z, \\\\ f_2\\left(\\boldsymbol{x}\\right) =3x+2y^2-zy. $$ 现需要计算的面积分项为： $$ I=\\int_{\\partial \\varOmega _k}{f_1\\left( \\boldsymbol{x} \\right) \\frac{\\partial f_2\\left( \\boldsymbol{x} \\right)}{\\partial y}}d\\boldsymbol{x}. $$ 其中\\(\\partial \\varOmega _k\\) 表示在第 \\(k\\)个四面体上的边界面。 不失一般性，定义两个如下图所示的两个相邻四面体\\(\\Omega _1\\) 和\\(\\Omega _2\\) ： 计算：两个四面体的交界面上的面积分。 方案1：直接积分由于函数表达式已知，我们可以直接得到 $$ \\frac{\\partial f_2\\left( \\boldsymbol{x} \\right)}{\\partial y}=4y-z. $$ 直接运用高斯积分，原来的积分项可以简化为： $$ I=\\int_{\\partial \\varOmega _k}{f_1\\left( \\boldsymbol{x} \\right) \\frac{\\partial f_2\\left( \\boldsymbol{x} \\right)}{\\partial y}}d\\boldsymbol{x}=\\sum_{k=1}^N{f_1\\left( \\boldsymbol{x}_k \\right) \\frac{\\partial f_2\\left( \\boldsymbol{x}_k \\right)}{\\partial y}w_k}. $$ 其中，\\(\\boldsymbol{x}_k\\) 为计算区域上的高斯积分点，\\(w_k\\) 为对应高斯积分点的权。 计算结果为：-0.166667。 方案2：坐标映射积分参考四面体首先，在局部坐标系下定义如下图所示的参考四面体： 从任意四面体\\(\\Omega _k\\)到参考四面体的映射关系为： $$ \\boldsymbol{x}=-\\frac{r+s+t+1}{2}\\boldsymbol{v}_{1}^{k}+\\frac{r+1}{2}\\boldsymbol{v}_{2}^{k}+\\frac{s+1}{2}\\boldsymbol{v}_{3}^{k}+\\frac{t+1}{2}\\boldsymbol{v}_{4}^{k}=\\varPsi \\left( \\boldsymbol{r} \\right) $$ 很容易检验上式只要代入在 \\(\\left(r,s,t\\right)\\) 坐标系下的参考四面体的四个顶点坐标，得到的就是实际四面体在 \\(\\left(x,y,z\\right)\\) 坐标系下的四个顶点坐标。 雅可比映射从实际四面体到参考四面体的映射为线性映射，映射之间的雅可比系数满足如下关系： $$ \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{r}}\\frac{\\partial \\boldsymbol{r}}{\\partial \\boldsymbol{x}}=\\left[ \\begin{matrix} x_r& x_s& x_t\\\\ y_r& y_s& y_t\\\\ z_r& z_s& z_t\\\\ \\end{matrix} \\right] \\left[ \\begin{matrix} r_x& r_y& r_z\\\\ s_x& s_y& s_z\\\\ t_x& t_y& t_z\\\\ \\end{matrix} \\right] =\\left[ \\begin{matrix} 1& 0& 0\\\\ 0& 1& 0\\\\ 0& 0& 1\\\\ \\end{matrix} \\right] ,J=\\det \\left( \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{r}} \\right) . $$ 其中\\(J\\)为雅可比矩阵行列式的值，可以通过映射的函数关系\\(\\boldsymbol{x}=\\varPsi \\left( \\boldsymbol{r} \\right)\\)求出。因此通过求雅可比矩阵的逆和左乘一个单元矩阵，容易就求出\\(r_x,r_y,r_z\\)等系数。 求导链法则由于函数\\(f_2(\\boldsymbol{x})\\) 是定义在四面体\\(\\Omega _2\\)上的函数，根据求导链法则可以得到： $$ \\frac{\\partial f_2\\left( \\boldsymbol{x} \\right)}{\\partial y}=\\frac{\\partial f_2\\left( \\boldsymbol{r} \\right)}{\\partial r}\\frac{\\partial r}{\\partial y}+\\frac{\\partial f_2\\left( \\boldsymbol{r} \\right)}{\\partial s}\\frac{\\partial s}{\\partial y}+\\frac{\\partial f_2\\left( \\boldsymbol{r} \\right)}{\\partial t}\\frac{\\partial t}{\\partial y}. $$ 根据上述的映射关系，有： $$ x=-0.5\\left( r+s+t+1 \\right) x_1+0.5\\left( r+1 \\right) x_2+0.5\\left( s+1 \\right) x_3+0.5\\left( t+1 \\right) x_4, \\\\ y=-0.5\\left( r+s+t+1 \\right) y_1+0.5\\left( r+1 \\right) y_2+0.5\\left( s+1 \\right) y_3+0.5\\left( t+1 \\right) y_4, \\\\ z=-0.5\\left( r+s+t+1 \\right) z_1+0.5\\left( r+1 \\right) z_2+0.5\\left( s+1 \\right) z_3+0.5\\left( t+1 \\right) z_4. $$ 代入\\(\\Omega _2\\)的四个顶点坐标，易得： $$ x=0.5\\left( s-r \\right) ,y=-0.5\\left( t+1 \\right) ,z=-0.5\\left( r+s+t+1 \\right) . $$ 在参考四面体下的函数\\(f_2\\left( \\boldsymbol{r} \\right)\\)可以表示为： $$ f_2\\left( \\boldsymbol{r} \\right) =3x\\left( \\boldsymbol{r} \\right) +2y\\left( \\boldsymbol{r} \\right) ^2-z\\left( \\boldsymbol{r} \\right) y\\left( \\boldsymbol{r} \\right) \\,\\, \\\\ =1.5\\left( s-r \\right) +0.5\\left( t+1 \\right) ^2-0.25\\left( t+1 \\right) \\left( r+s+t+1 \\right) $$ 对于的偏导项分别为： $$ \\frac{\\partial f_2\\left( \\boldsymbol{r} \\right)}{\\partial r}=-1.5-0.25\\left( t+1 \\right) , \\\\ \\frac{\\partial f_2\\left( \\boldsymbol{r} \\right)}{\\partial s}=1.5-0.25\\left( t+1 \\right) , \\\\ \\frac{\\partial f_2\\left( \\boldsymbol{r} \\right)}{\\partial t}=0.5\\left( t+1 \\right) -0.25\\left( r+s \\right) . $$ 通过雅可比矩阵可以计算出系数：\\(r_y=1,s_y=1,t_y=-2.\\)对积分而言，我们可以将其简化为： $$ I_2=J_{f}^{k}\\int_{\\partial \\varOmega _k}{f_1\\left( \\boldsymbol{r} \\right) \\left( \\frac{\\partial f_2\\left( \\boldsymbol{r}^+ \\right)}{\\partial r}\\frac{\\partial r}{\\partial y}+\\frac{\\partial f_2\\left( \\boldsymbol{r}^+ \\right)}{\\partial s}\\frac{\\partial s}{\\partial y}+\\frac{\\partial f_2\\left( \\boldsymbol{r}^+ \\right)}{\\partial t}\\frac{\\partial t}{\\partial y} \\right)}dS. $$ 其中面上的雅可比系数\\(J{f}^{k}\\)为实际面与映射面的面积之比。 积分点匹配注意到\\(\\Omega _1\\)在交界面上是映射到参考单元 \\((\\boldsymbol{v_2,v_3,v_4})\\) 构成的面，而\\(\\Omega _2\\)是映射到\\((\\boldsymbol{v_2,v_3,v_4})\\)所构成的面。由于我们是预先在参考四面体上生成了高斯积分点，当想采用高斯积分来求解的时候，需要在两个面之间做一个高斯积分点匹配的过程。例如，如下图所示，在左边的四面体上交界面映射到的是参考单元的\\((\\boldsymbol{v_2,v_3,v_4})\\)面，右边四面体的交界面映射到的是参考单元的\\((\\boldsymbol{v_1,v_3,v_4})\\)面，实际交界面上的同一个点由左边的四面体映射到的是一个面上的 3 号积分点，而右边四面体映射到的是另一个面上的 5 号积分点。我们可以选择在两个面上的任意一个面做积分，只是不同面上的雅可比系数\\(J_{f}^{k}\\)有所不同。 在本文中以第一个四面体\\(\\Omega _1\\)在交界面映射到参考单元的 \\((\\boldsymbol{v_2,v_3,v_4})\\) 面为积分面，对\\(\\Omega _2\\)映射到第\\((\\boldsymbol{v_1,v_2,v_3})\\)面做高斯积分点匹配，结果如下图所示。 最后求解通过求雅可比系数和建立高斯积分点匹配表，我们可以最后求解得到该面积分的值为−0.166667，和方案1是一致的。 总结通过对比两种高斯积分方案，验证了参考四面体上进行积分映射可以得到实际四面体上的积分。这样做的好处是，在有限元算法中我们只需要存储一个参考四面体上的矩阵和一些与实际四面体相关的雅可比系数，而不需要对实际中每一个四面体都存矩阵，这样就实现了低存储的方案。 附录：C++代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;Eigen/dense&gt;using namespace Eigen;using namespace std;#define Length(a) (sizeof(a)/sizeof(a[0]))/* 2D */#define Perm3(a) double(a),double(a),double(a)#define Dup3(w) w#define Perm21(a) double(1.)-a-a,a,a, a,double(1.)-a-a,a, a,a,double(1.)-a-a#define Dup21(w) w,w,w#define Perm111(a,b) a,b,double(1.)-a-b, a,double(1.)-a-b,b, b,a,double(1.)-a-b, b,double(1.)-a-b,a, double(1.)-a-b,a,b, double(1.)-a-b,b,a#define Dup111(w) w,w,w,w,w,wdouble QUAD_2D_P15_wts[] = { Dup3(.02357126703190634206659321140821418), Dup21(.01517314955721170450311858877690239), Dup21(.01297600128392884154979521077280757), Dup21(.01706629596800615670942600046160914), Dup21(.04576001946273760698482638108892258), Dup111(.00222757447282223154006065426298478), Dup111(.02701014165986947101315702212247500), Dup111(.02608377963958756403057720483642768), Dup111(.01211015327702828337230795926322736), Dup111(.01564785059680444573399007149035058), Dup111(.03417088937929479242522512890637806)};double QUAD_2D_P15_pts[Length(QUAD_2D_P15_wts) * 3] = { Perm3(.33333333333333333333333333333333333), Perm21(.11022229622834687297855264132259850), Perm21(.05197643301003435047003197947889073), Perm21(.49114565807532554119014945122395425), Perm21(.39315718888435884048226809785071794), Perm111(.03737440487572919066543605209836625, .96251835223001214880811969560396873), Perm111(.24824877798467321198263980694374938, .19316669854521416819773100288721521), Perm111(.20699402274830217740486528153682148, .08689590883549962551575259619781217), Perm111(.14854110526954708137688902238435510, .01743682539845430796259020511767948), Perm111(.30674237923596382376588728350286621, .01749251095825766163254977051260599), Perm111(.36703198754220473278855469116984882, .09034802175864556044634095119222305)};void Real_Quad_Pts_2D(double **p, double x[], double y[], double z[]);void Area_face(double *Area, double x[], double y[], double z[]);void main() { // elem1 double x_elem1[4] = { 0, 1,-1, 0 }; double y_elem1[4] = { 1, 0, 0, 0 }; double z_elem1[4] = { 0, 0, 0, 1 }; // elem2 double x_elem2[4] = { 0,-1, 1, 0 }; double y_elem2[4] = { 0, 0, 0,-1 }; double z_elem2[4] = { 1, 0, 0, 0 }; // guass integral order int order = 15; int quad_num_2D = 49; double Area[4]; double *quad_2D_wts = QUAD_2D_P15_wts; double **quad_pts_face = new double *[12]; for (int i = 0; i &lt; 12; ++i) { quad_pts_face[i] = new double[quad_num_2D]; } // the interface between two tetrahedrons is face[2] Area_face(Area, x_elem1, y_elem1, z_elem1); Real_Quad_Pts_2D(quad_pts_face, x_elem1, y_elem1, z_elem1); // plan A double *f1 = new double[quad_num_2D]; double *f2 = new double[quad_num_2D]; double *dyf2 = new double[quad_num_2D]; int idxface = 2; for (int i = 0; i &lt; quad_num_2D; ++i) { double x = quad_pts_face[idxface * 3][i]; double y = quad_pts_face[idxface * 3 + 1][i]; double z = quad_pts_face[idxface * 3 + 2][i]; f1[i] = 2 * x + 4 * y + z; f2[i] = 3 * x + 2 * y * y - z * y; dyf2[i] = 4 * y - z; } double result1 = 0; for (int i = 0; i &lt; quad_num_2D; ++i) { result1 += f1[i] * dyf2[i] * quad_2D_wts[i] * Area[idxface]; } // plan B // reference element double x_ref[4] = { -1,1,-1,-1 }; double y_ref[4] = { -1,-1,1,-1 }; double z_ref[4] = { -1,-1,-1,1 }; double **quad_pts_face_ref = new double *[12]; for (int i = 0; i &lt; 12; ++i) { quad_pts_face_ref[i] = new double[quad_num_2D]; } double Area_ref[4]; Area_face(Area_ref, x_ref, y_ref, z_ref); Real_Quad_Pts_2D(quad_pts_face_ref, x_ref, y_ref, z_ref); double *f1_ref = new double[quad_num_2D]; double *drf2 = new double[quad_num_2D]; double *dsf2 = new double[quad_num_2D]; double *dtf2 = new double[quad_num_2D]; double *quad_2D_wts_ref = QUAD_2D_P15_wts; // r s t to x y z on gauss integral point int idxface1 = 2; int idxface2 = 0; VectorXd r1 = VectorXd::Zero(quad_num_2D); VectorXd s1 = VectorXd::Zero(quad_num_2D); VectorXd t1 = VectorXd::Zero(quad_num_2D); VectorXd r2 = VectorXd::Zero(quad_num_2D); VectorXd s2 = VectorXd::Zero(quad_num_2D); VectorXd t2 = VectorXd::Zero(quad_num_2D); for (int i = 0; i &lt; quad_num_2D; ++i) { r1[i] = quad_pts_face_ref[idxface1 * 3][i]; s1[i] = quad_pts_face_ref[idxface1 * 3 + 1][i]; t1[i] = quad_pts_face_ref[idxface1 * 3 + 2][i]; } for (int i = 0; i &lt; quad_num_2D; ++i) { r2[i] = quad_pts_face_ref[idxface2 * 3][i]; s2[i] = quad_pts_face_ref[idxface2 * 3 + 1][i]; t2[i] = quad_pts_face_ref[idxface2 * 3 + 2][i]; } VectorXd x1 = VectorXd::Zero(quad_num_2D); VectorXd y1 = VectorXd::Zero(quad_num_2D); VectorXd z1 = VectorXd::Zero(quad_num_2D); VectorXd x2 = VectorXd::Zero(quad_num_2D); VectorXd y2 = VectorXd::Zero(quad_num_2D); VectorXd z2 = VectorXd::Zero(quad_num_2D); VectorXd OnesNp = VectorXd::Ones(quad_num_2D); x1 = 0.5*(-(OnesNp + r1 + s1 + t1)*x_elem1[0] + (OnesNp + r1)*x_elem1[1] + (OnesNp + s1)*x_elem1[2] + (OnesNp + t1)*x_elem1[3]); y1 = 0.5*(-(OnesNp + r1 + s1 + t1)*y_elem1[0] + (OnesNp + r1)*y_elem1[1] + (OnesNp + s1)*y_elem1[2] + (OnesNp + t1)*y_elem1[3]); z1 = 0.5*(-(OnesNp + r1 + s1 + t1)*z_elem1[0] + (OnesNp + r1)*z_elem1[1] + (OnesNp + s1)*z_elem1[2] + (OnesNp + t1)*z_elem1[3]); x2 = 0.5*(-(OnesNp + r2 + s2 + t2)*x_elem2[0] + (OnesNp + r2)*x_elem2[1] + (OnesNp + s2)*x_elem2[2] + (OnesNp + t2)*x_elem2[3]); y2 = 0.5*(-(OnesNp + r2 + s2 + t2)*y_elem2[0] + (OnesNp + r2)*y_elem2[1] + (OnesNp + s2)*y_elem2[2] + (OnesNp + t2)*y_elem2[3]); z2 = 0.5*(-(OnesNp + r2 + s2 + t2)*z_elem2[0] + (OnesNp + r2)*z_elem2[1] + (OnesNp + s2)*z_elem2[2] + (OnesNp + t2)*z_elem2[3]); double tol = 1e-8; VectorXi VmapP = VectorXi::Zero(quad_num_2D); for (int i = 0; i &lt; quad_num_2D; ++i) { VmapP[i] = i; for (int j = 0; j &lt; quad_num_2D; ++j) { double distmp = sqrt((x1[i] - x2[j])*(x1[i] - x2[j]) + (y1[i] - y2[j])*(y1[i] - y2[j]) + (z1[i] - z2[j])*(z1[i] - z2[j])); if (distmp &lt; tol) { VmapP[i] = j; break; } } } double sJ = Area[idxface1] / Area_ref[idxface1]; double ry = 1, sy = 1, ty = -2; for (int i = 0; i &lt; quad_num_2D; ++i) { double r_1 = quad_pts_face_ref[idxface1 * 3][i]; double s_1 = quad_pts_face_ref[idxface1 * 3 + 1][i]; double t_1 = quad_pts_face_ref[idxface1 * 3 + 2][i]; double r_2 = quad_pts_face_ref[idxface2 * 3][VmapP[i]]; double s_2 = quad_pts_face_ref[idxface2 * 3 + 1][VmapP[i]]; double t_2 = quad_pts_face_ref[idxface2 * 3 + 2][VmapP[i]]; drf2[i] = -1.5 - 0.25*(t_2 + 1); dsf2[i] = 1.5 - 0.25*(t_2 + 1); dtf2[i] = 0.5*(t_2 + 1) - 0.25*(r_2 + s_2); f1_ref[i] = (-r_1 - 3 * s_1 - 1.5*t_1 - 1.5); } double result2 = 0; for (int i = 0; i &lt; quad_num_2D; ++i) { result2 += f1_ref[i] * (drf2[i] * ry + dsf2[i] * sy + dtf2[i] * ty) * quad_2D_wts[i] * Area_ref[idxface1]; } cout &lt;&lt; &quot; result1 = &quot; &lt;&lt; result1 &lt;&lt; endl; cout &lt;&lt; &quot; result2 = &quot; &lt;&lt; result2*sJ &lt;&lt; endl; system(&quot;pause&quot;);}void Real_Quad_Pts_2D(double **p, double x[], double y[], double z[]){ int Num_of_Quad = 49, i; double *quad_2D_pts = 0; quad_2D_pts = QUAD_2D_P15_pts; double x_f[3], y_f[3], z_f[3]; //face 1:1 2 3 x_f[0] = x[0]; x_f[1] = x[1]; x_f[2] = x[2]; y_f[0] = y[0]; y_f[1] = y[1]; y_f[2] = y[2]; z_f[0] = z[0]; z_f[1] = z[1]; z_f[2] = z[2]; for (i = 0; i &lt; Num_of_Quad; ++i) { p[0][i] = x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2]; p[1][i] = y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2]; p[2][i] = z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2]; } //face 2:1 2 4 x_f[0] = x[0]; x_f[1] = x[1]; x_f[2] = x[3]; y_f[0] = y[0]; y_f[1] = y[1]; y_f[2] = y[3]; z_f[0] = z[0]; z_f[1] = z[1]; z_f[2] = z[3]; for (i = 0; i &lt; Num_of_Quad; ++i) { p[3][i] = x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2]; p[4][i] = y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2]; p[5][i] = z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2]; } //face 3:2 3 4 x_f[0] = x[1]; x_f[1] = x[2]; x_f[2] = x[3]; y_f[0] = y[1]; y_f[1] = y[2]; y_f[2] = y[3]; z_f[0] = z[1]; z_f[1] = z[2]; z_f[2] = z[3]; for (i = 0; i &lt; Num_of_Quad; ++i) { p[6][i] = x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2]; p[7][i] = y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2]; p[8][i] = z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2]; } //face 4:1 3 4 x_f[0] = x[0]; x_f[1] = x[2]; x_f[2] = x[3]; y_f[0] = y[0]; y_f[1] = y[2]; y_f[2] = y[3]; z_f[0] = z[0]; z_f[1] = z[2]; z_f[2] = z[3]; for (i = 0; i &lt; Num_of_Quad; ++i) { p[9][i] = x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2]; p[10][i] = y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2]; p[11][i] = z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2]; }}void Area_face(double *Area, double x[], double y[], double z[]){ double Len[3], x_f[3], y_f[3], z_f[3]; //face 1:1 2 3 x_f[0] = x[0]; x_f[1] = x[1]; x_f[2] = x[2]; y_f[0] = y[0]; y_f[1] = y[1]; y_f[2] = y[2]; z_f[0] = z[0]; z_f[1] = z[1]; z_f[2] = z[2]; Len[0] = sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0)); Len[1] = sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0)); Len[2] = sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0)); Area[0] = sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])* (Len[1] + Len[2] - Len[0])) / 4; //face 2:1 2 4 x_f[0] = x[0]; x_f[1] = x[1]; x_f[2] = x[3]; y_f[0] = y[0]; y_f[1] = y[1]; y_f[2] = y[3]; z_f[0] = z[0]; z_f[1] = z[1]; z_f[2] = z[3]; Len[0] = sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0)); Len[1] = sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0)); Len[2] = sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0)); Area[1] = sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])* (Len[1] + Len[2] - Len[0])) / 4; //face 3:2 3 4 x_f[0] = x[1]; x_f[1] = x[2]; x_f[2] = x[3]; y_f[0] = y[1]; y_f[1] = y[2]; y_f[2] = y[3]; z_f[0] = z[1]; z_f[1] = z[2]; z_f[2] = z[3]; Len[0] = sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0)); Len[1] = sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0)); Len[2] = sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0)); Area[2] = sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])* (Len[1] + Len[2] - Len[0])) / 4; //face 4:1 3 4 x_f[0] = x[0]; x_f[1] = x[2]; x_f[2] = x[3]; y_f[0] = y[0]; y_f[1] = y[2]; y_f[2] = y[3]; z_f[0] = z[0]; z_f[1] = z[2]; z_f[2] = z[3]; Len[0] = sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0)); Len[1] = sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0)); Len[2] = sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0)); Area[3] = sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])* (Len[1] + Len[2] - Len[0])) / 4;}","link":"/2021/10/08/211008_tetra_integral/"}],"tags":[{"name":"std::bind","slug":"std-bind","link":"/tags/std-bind/"},{"name":"c++标准库","slug":"c-标准库","link":"/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"},{"name":"std::function","slug":"std-function","link":"/tags/std-function/"},{"name":"lambda表达式","slug":"lambda表达式","link":"/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"少年维特的烦恼","slug":"少年维特的烦恼","link":"/tags/%E5%B0%91%E5%B9%B4%E7%BB%B4%E7%89%B9%E7%9A%84%E7%83%A6%E6%81%BC/"},{"name":"最完美的离婚","slug":"最完美的离婚","link":"/tags/%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84%E7%A6%BB%E5%A9%9A/"},{"name":"S参数","slug":"S参数","link":"/tags/S%E5%8F%82%E6%95%B0/"},{"name":"分贝dB","slug":"分贝dB","link":"/tags/%E5%88%86%E8%B4%9DdB/"},{"name":"傅里叶变换","slug":"傅里叶变换","link":"/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"},{"name":"猎户座","slug":"猎户座","link":"/tags/%E7%8C%8E%E6%88%B7%E5%BA%A7/"},{"name":"高斯积分","slug":"高斯积分","link":"/tags/%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86/"}],"categories":[{"name":"编程基础","slug":"编程基础","link":"/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"电磁场理论","slug":"电磁场理论","link":"/categories/%E7%94%B5%E7%A3%81%E5%9C%BA%E7%90%86%E8%AE%BA/"},{"name":"信号处理","slug":"信号处理","link":"/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"天文","slug":"天文","link":"/categories/%E5%A4%A9%E6%96%87/"},{"name":"数值方法","slug":"数值方法","link":"/categories/%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/"}]}