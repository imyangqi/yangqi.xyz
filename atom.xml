<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时间之矢</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-24T01:46:49.950Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨琦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微波网络中的分贝值</title>
    <link href="http://example.com/2021/07/18/210718_em_power_dB/"/>
    <id>http://example.com/2021/07/18/210718_em_power_dB/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-07-24T01:46:49.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们在仿真天线或者一些微波器件的时候，S参数是很重要的参数之一，关于S参数的定义在很多微波工程中的书都能找到，但是对于具体如何计算，却很少有教科书会提及，这些概念大多散落在CEM领域的一些专业论文里面。本文旨在介绍几种常用激励端口下的S参数提取。<a id="more"></a></p><h2 id="关于分贝值-dB"><a href="#关于分贝值-dB" class="headerlink" title="关于分贝值(dB)"></a>关于分贝值(dB)</h2><p>通常我们在商业软件中计算出来的S参数都是用dB值来表示，这是由于在微波系统中两功率电平P1和P2之比经常用分贝(dB)来表示，即</p><div>$$10\log _{10}\frac{P_1}{P_2}\mathrm{dB}$$</div>不难发现用这种定义方法后，当功率之比为2时等效为3dB，功率比为0.1时等效为-10dB。这使得在计算元器件之前的功率损耗和增益中变得容易，因为相乘的损耗或增益因子可以通过对每一级用分贝表示的损耗或增益的相加来计算。例如，当一个信号经过一个6dB的衰减器和一个23dB的放大器之后，将具有23-6=17dB的总增益。<p>值得注意的是，在微波网络中分贝值只表示为功率比，但有时候也可以用电压来表示功率比，由于 \( P_1=V_{1}^{2}R_1\) 和\(P_2=V_{2}^{2}R_2\)，因此有</p><div>$$10\log _{10}\frac{V_{1}^{2}R_2}{V_{2}^{2}R_1}=20\log \frac{V_1}{V_2}\sqrt{\frac{R_2}{R_1}}\mathrm{dB}$$</div><p>其中，\(R_1\)和\(R_2\)为负载电阻，\(V_1\)和\(V_2\)为负载电压，如果负载电阻相等，那么公式可以简化为</p><div>$$20\log \frac{V_1}{V_2}\mathrm{dB}$$</div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们在仿真天线或者一些微波器件的时候，S参数是很重要的参数之一，关于S参数的定义在很多微波工程中的书都能找到，但是对于具体如何计算，却很少有教科书会提及，这些概念大多散落在CEM领域的一些专业论文里面。本文旨在介绍几种常用激励端口下的S参数提取。</summary>
    
    
    
    <category term="电磁场理论" scheme="http://example.com/categories/%E7%94%B5%E7%A3%81%E5%9C%BA%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="S参数" scheme="http://example.com/tags/S%E5%8F%82%E6%95%B0/"/>
    
    <category term="分贝dB" scheme="http://example.com/tags/%E5%88%86%E8%B4%9DdB/"/>
    
  </entry>
  
  <entry>
    <title>光生写给结夏的信</title>
    <link href="http://example.com/2021/05/20/210520_letter_guangsheng_to_jiexia/"/>
    <id>http://example.com/2021/05/20/210520_letter_guangsheng_to_jiexia/</id>
    <published>2021-05-19T16:00:00.000Z</published>
    <updated>2021-05-20T05:57:40.916Z</updated>
    
    <content type="html"><![CDATA[<p>最近看完了日剧《最完美的离婚》，没想到在特别篇的结尾，光生和结夏还是分手了。</p><p>很久之后，光生写下了这样一封信给结夏。看完信被深切感动到了。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27571309&auto=0&height=66"></iframe><p>星野结夏小姐：</p><p>春寒料峭，你是否安好？没有感冒吧？没有长冻疮吧？对不起，突然给你写信。如果能承蒙你在寒夜中雅鉴，不胜荣幸。</p><p>首先，向你报告，在我们家即将迎来第三个年头的两只猫的情况。不知为何，它们最近经常看电视，边看股票的新闻边交谈。对它们的人生来说，股票有什么作用呢？</p><p>金鱼咖啡，因为姐姐要调养身体，最近继男姐夫在画咖啡拉花，画风独辟蹊径，经常有女性客人失望而归。</p><p>经由上原先生介绍，前几天终于见到了河合先生。我很震惊，河合先生是位希腊雕像一样的大帅哥。他伸手同我握手，说，“初次见面”，不知道能不能和他成为朋友。</p><p>在目黑川来来往往的人们，抬头看着樱花树，期待着开花时节，已经互相定下了赏花的约定，那个热闹的季节又要到来了。</p><p>昨天我梦到你了，梦见你抱着好多气球。你把无数个气球系在我和你的身上，我和你被气球带起，飞上了天空。俯瞰着目黑川，发现玛蒂尔达和八朔在抬头看着我们，上原夫妇抱着小婴儿朝我们招手。我只能被气球带着，随风飘荡，对自己的无力有点悲伤。</p><p>我现在依然每天会走过岸边的街道，不可思议的是，并不觉得自己是一个人。我依然每天都同你的记忆一起生活着。你经常在浴室里唱的歌，“静静地，静静地，握起你的手，握起你的手”，这样开头的歌，这样的场景。</p><p>想起深夜两个人出门借DVD的那一次，我和你注意到月亮已经变得好大，一时忘了出门的理由，在夜色中散起步来。在旧山手路买了烤红薯，掰成两半之后，发现大小相差悬殊，于是猜拳决定。吃着红薯，笑着，牵着手。我说要结婚，你的嘴巴被红薯塞得满满囔囔的，含糊不清地回答了我，这样的开始，这样的场景。</p><p>和你结婚后，我懂得了很多事。洗手台上并排着的牙刷，被窝中碰到的脚，不知何时消失掉的冰箱中的布丁，先下楼梯，和在你的后面上楼梯……恋爱总有一天会变成生活，生活会变成喜悦。穿错了女生袜子出门，发邮件来拜托我录的电视节目，抓背，做噩梦了就互相依偎，另一位父亲，另一位母亲，另一个家乡，家乡寄来的装在蜜柑箱子里的白菜，由生活演奏的音乐，在生活中互相传达的故事……这里还四处散落着，房间的角落里，电灯泡的里面，窗帘的缝隙里，还同以前一样留着。我如今也每天感受着从过去而来的你所留下的爱情。</p><p>我今天也会走过河边的街道，各自拥有的两个人一起生活过的回忆，住在我心中的你，闯进你世界的我，不可思议的，并不觉得变成了一个人。总有一天会觉得这样的想法太过愚蠢，却还是这样想着，在夜色中散步，猜拳决定，吃着烤红薯，笑着，牵着手，吃着满口的烤红薯，再说起同样的话。</p><p>我们在一起的话会很开心吧？一起慢慢变老吧？<br>可以嫁给我吗？</p><p>2014年2月8日</p><p>我在目黑川岸边的旧公寓，和两只猫一起，等待着春天的来临。 </p><p>日文原文：</p><p>星野　結夏さま：</p><p>暦（こよみ）の上に春は立ちながら厳しい寒さが続いておりますがいかがお過ごしですか？風邪などひいていませんか？霜焼（しもや）けなどしていませんか？突然の手紙ごめんなさい。まだまだ寒く長い夜のついでに目を通していただければ幸（さいわ）いです。</p><p>まずわが家に暮らして３年目を迎える２匹（ひき）の猫に関してお知らせします。彼らはなぜか最近テレビをよく見ます。株価のニュースを見ながら話をしています。彼らの人生に株価が何か作用（さよう）することがあるのでしょうか？</p><p>金魚（きんぎょ）カフェでは姉の体調もあって最近継男（つぐお）さんがラテアートを描（か）いています。その絵の作風（さくふう）が常軌（じょうき）を逸（いっ）しており女性客が悲鳴（ひめい）を上げて帰ることしばしばです。</p><p>上原さんに紹介されて先日ついに河合さんと対面しました。驚きです。河合さんはまるでギリシャ彫刻（ちょうこく）のような二枚目だったのです。握手の手を差し伸べ「やあ、初めまして」とおっしゃっていました。友達になれるかどうかはちょっと分かりません。</p><p>目黒川を行き交（か）う人々は桜の木を見上げて開花（かいか）の時季（じき）を待ちわびながら、すでに花見の約束を取り交わしています。また、あのにぎやかな季節が訪（おとず）れるのですね！</p><p>昨日、君の夢を見ました。君がたくさんの風船（ふうせん）を抱（かか）えてくる夢でした。君は無数（むすう）の風船を僕と自分の体に結（むす）び付けました。僕と君は風船に軽く体を持ち上げられて空を飛びました。目黒川を見下ろすとマチルダとはっさくが見上げてるのが見えました。上原さんたちが赤ん坊を抱いて手を振っていました。僕は風に流されて飛んでいくしかない、自分の非力さが少し悲しかったです。</p><p>川沿（ぞ）いの道を今日も歩きます。不思議と一人になった気がしません。まだまだ僕は毎日を君の記憶と共に暮らしています。君がよくお風呂場で歌っていた歌、「静かに　静かに　手を取り　手を取り」、そんなふうに始まる歌、そんな光景。</p><p>深夜二人でDVDを借りに出掛けたときのこと、月がずいぶんと大きなことに気がついた僕と君は、そもそもなぜ出掛けたのかさえ忘れて、夜中の散歩をしました。旧山手通りで焼き芋（いも）を買って、半分に割ったら大きさがまるで違って、じゃんけんして食べて、笑って、手をつないで、僕が結婚を口にしたら、君は焼き芋いっぱい頬張（ほおば）った口で声にならない返事をしました。そんな始まり、そんな光景。</p><p>君と結婚して知ったことがあります。洗面台（せんめんだい）に並んだ歯ブラシ、ベッドの中でぶつかる足、いつの間にか消えてる冷蔵庫のプリン、階段を先に下りること、階段を後から上がること、恋がいつしか日常に変わること、日常が喜びに変わること、間違えてはいて出掛けた女物の靴下、メールで頼まれる番組録画（ろくが）、背中をかくこと、怖い夢を見たら寄り添（そ）うこと、もう一人の父親、もう一人の母親、もう一つの古里、古里から届くミカン箱の中のハクサイ、日常が奏（かな）でる音楽、日常を伝え合うことの物語（ものがたり）．．．ここにはまだそれが転がっています。部屋の隅に電球の裏にカーテンの隙間（すきま）にくっついたまま。僕は今も毎日のように過去から訪れる君の愛情を受け取っています。</p><p>川沿いの道を今日も歩きます。一人ずつ二人で生きていたこと、僕の中に住んでいる君、君の中に迷い込んだ僕、不思議と一人になった気がしません。いつかまたそう思うことの愚（おろ）かさを思いながらそれでも思います。夜中の散歩をして、じゃんけんして、食べて、笑って、手をつないで、焼き芋頬張りながら、また同じことを話すんです。</p><p>僕たち一緒にいると、楽しいよね？一緒に年を取りませんか？<br>結婚してくれませんか？</p><p>２０１４年２月８日</p><p>目黒川沿いの古いマンションで２匹の猫と共に春の訪れを待っています。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看完了日剧《最完美的离婚》，没想到在特别篇的结尾，光生和结夏还是分手了。&lt;/p&gt;
&lt;p&gt;很久之后，光生写下了这样一封信给结夏。看完信被深切感动到了。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="最完美的离婚" scheme="http://example.com/tags/%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84%E7%A6%BB%E5%A9%9A/"/>
    
  </entry>
  
  <entry>
    <title>《少年维特的烦恼》读书笔记</title>
    <link href="http://example.com/2021/05/05/210505_The_Sorrows_of_Young_Werther/"/>
    <id>http://example.com/2021/05/05/210505_The_Sorrows_of_Young_Werther/</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-05-05T14:24:38.929Z</updated>
    
    <content type="html"><![CDATA[<p>五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=316000&auto=1&height=66"></iframe><p>故事中维特为了逃避世事的纷扰，只身来到瓦尔海姆。在一次去乡村舞会的路上，他结识了天使般美丽纯洁的少女夏绿蒂，并对她一见倾心，陷入爱河。这时的绿蒂已经和一个名叫阿尔伯特的人订了婚，阿尔伯特为人正直、诚实、可靠，就连绿蒂也认为：阿尔伯特的“稳重可靠仿佛天生可以作为一种基础，好让一个贤淑的女子在上面建立幸福的生活”。面对看起来如此般配的一对人，维特对绿蒂的爱情烈火并没有就此熄灭，而是越来越旺，维特几乎不能自己。一面是自己深爱的女子，一面是对自己友善的阿尔伯特——她的未婚夫，在三个人的爱情角逐中，维特经过矛盾和痛苦挣扎后不得不忍痛退出，去了一家很远的公使馆担任书记官，然而这里的生活并不如意，他常常郁郁寡欢，彷徨苦闷。最后他又回到了绿蒂身边，这时的绿蒂已经和阿尔伯特结婚，婚后的生活并不愉快。失去维特后，绿蒂的内心空虚寂寥，和维特的久别重逢，使他们再一次陷入爱情的深潭，不可自拔。维特对绿蒂的爱之深切与不能得到绿蒂的矛盾，又使他陷入绝望的境地，极度痛苦的维特最后举枪自杀。</p><p>对于维特最后的选择令我感到心痛，但又理解他的选择。美剧《无耻之徒》里面有一句台词：</p><blockquote><p>Love is not supposed to be cute, love is raw and destructive.<br>爱从来都不是什么可爱的东西，爱是生猛而具有毁灭性的。</p></blockquote><p>维特曾是那么地热爱着自然：</p><blockquote><p>每当我周围的可爱峡谷霞气蒸腾，杲杲的太阳悬挂在林梢，将它的光芒这儿那儿地偷射进幽暗密林的圣地中来时，我便躺卧在飞泉侧畔的茂草里，紧贴地面观察那千百种小草，感觉到叶茎间有个扰攘的小小世界——这数不尽也说不清的形形色色的小虫子、小蛾子——离我的心更近了，于是我感受到按自身模样创造我们的全能的上帝存在，感受到将我们托付于永痕欢乐海洋之中的博爱天父的嘘息。——五月十日</p></blockquote><p>和那么地喜欢着孩子们：</p><blockquote><p>是的，威廉，在这个世界上离我的心最近的是孩子们。每当我从旁边观察他们，从细小的事情中发现他们有朝一日所需要的种种品德与才能的萌芽，从他们今日的固执任性中看出将来的坚毅与刚强，从今日的顽皮放肆中看出将来的幽默乐观以及轻松愉快地应付人世危难的本领，每当我发现这一切还丝毫未经败坏，完整无损，我便一次一次地，反反复复地，吟味人类的导师[1]这句金言。——六月二十九日</p><p>注释：[1]指耶稣。事见《圣经·新约·马太福音》第十八章：耶稣对门徒说：”你们若不回转，变成小孩子的样子，断不得进天国。“</p></blockquote><p>每当我在书中读到维特在自然界中感受到美妙之处，以及和孩子们相处时的快乐，便会联想到自己也是那么地喜欢着大自然和孩子们，很多次走在家乡的田野里，小河边，独自寻觅着路边的野花，静静地聆听潺潺的水流声，和孩子们一起分享食物，教他们使用电脑，给他们布置玩耍的场地，从他们的热情和善良中感受到这个世界的可爱。</p><p>歌德完成这部作品前后只花了四周的时间，之所以能如此高效是因为这部作品中的大部分内容都来自歌德自身的经历。1772年5月，歌德遵循父命到威茨拉尔的帝国高等法院实习。威茨拉尔是座空气陈腐得令人窒息的小城，帝国法院更以办事拖沓而恶名远播。歌德因此把实习的事情抛到脑后，终日悠游于景色宜人的乡间，在那儿研读荷马、品达等人的作品，做他感兴趣的事情。6月9日，在一次乡村舞会上，他结识了天真美丽的少女夏绿蒂·布甫，对她产生了热烈的爱慕。但夏绿蒂已经订婚。尽管她的未婚夫科斯特纳和夏绿蒂一家对歌德都十分友善，但他仍因失恋而感到痛苦，终于在9月11日不辞而别，回到法兰克福。</p><p>回到故乡以后，歌德久久未能克服心头的苦闷，以致产生了自杀的念头。谁料差不多就在这个时候，另一个人却把他几经尝试而放弃的事情完成了，一个他认识的叫耶鲁撒冷的青年自杀了。出事地点也正好在威茨拉尔，歌德在散步时还常常与他相遇。而且自杀的主要原因也同为恋慕他人之妻遭到拒斥。这种种情况，不能不令歌德联想到自身的遭遇，对同病相怜的耶鲁撒冷的不幸感到切肤之痛。</p><p>再后来，1774年初，女作家索菲的女儿玛克西米莲娜嫁给了一个名叫勃伦塔诺的富商，移居到了法兰克福。前年，歌德从威茨拉尔返回故乡时，曾顺便访问她家，对她颇有好感。如今重逢，两人都甚为欣喜。可惜这幸福很快变成了新的痛苦源泉，勃伦塔诺比玛克西米莲娜大二十岁，已经时有五个孩子的鳏夫，除去做生意赚钱别无所长，性情急躁而好嫉妒，很快对两个年轻人的交往产生疑忌，以致和歌德产生激烈冲突。这新的痛苦狠狠触动了歌德心灵中旧有的创伤，使他感到更加痛苦。为了彻底医治好自己的伤痛，歌德便愤而提笔，开始了维特的写作。</p><p>年轻的歌德完全进入了创作的狂热和忘我地境地，就像个梦游者似的，在几乎是无意识的状态下写成了这本小册子，以致当他最后拿起手稿来进行修改润饰时，自己也感到十分惊讶。维特一书之所以能如此情真意切，感人肺腑，这都是因为歌德的亲身感受。</p><p>在信息发达的现代社会，经常能看见新闻有人因为各种原因而结束自己的生命，有时候很难去体会当事者要经历多大的痛苦，才会选择直面死亡，以死亡来结束掉这一切。我知道，这种决定并不是一瞬间完成的，而是从出生到当下的一种经历的积分式结果。我不会也没有权力去指责他人的决定，但我仍会感到惋惜，或许只要再等一等，就能体会到这个世界的一点点美好之处，而放弃结束生命的念头。</p><p>生命的意义是什么？我时常思考这个问题，但每个阶段得到的答案都不尽相同。现在的我觉得生命的意义在于爱，这种爱是对世间万物的爱，对他人的爱。一个人如果只考虑自身的利益，会很容易让自己陷入到一种狭隘的境地，无法去体会世界的美好和可爱之处。我们要去爱他人，去帮助他人，在爱人的过程中感受到被爱，从而建立人与人之间的羁绊。维系着我们生活下去的，正是这一份一份的羁绊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="少年维特的烦恼" scheme="http://example.com/tags/%E5%B0%91%E5%B9%B4%E7%BB%B4%E7%89%B9%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::bind用法总结</title>
    <link href="http://example.com/2021/04/28/210428_cpp_std_bind/"/>
    <id>http://example.com/2021/04/28/210428_cpp_std_bind/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-05T08:48:59.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>std::bind</code>包含在标准库头文件<code>#include&lt;functional&gt;</code>中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。<a id="more"></a></p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p> <code>std::bind</code>使用的一般形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, arg_list);</span><br></pre></td></tr></table></figure><p> 其中<code>fun</code>是一个函数，<code>arg_list</code>是用逗号隔开的参数列表。调用<code>new_fun()</code>相当于调用<code>fun(arg_list)</code>。 </p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="用法一：改变参数的个数"><a href="#用法一：改变参数的个数" class="headerlink" title="用法一：改变参数的个数"></a>用法一：改变参数的个数</h3><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders; </span><br></pre></td></tr></table></figure><p>现在定义一个函数，接收一个数组<code>array</code>，数组长度<code>n</code>和某个数<code>num</code>，它将实现打印数组中大于<code>num</code>的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [](<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> num)&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; num)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; ends;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>利用<code>std::bind</code>函数将原来函数调用所需要的参数固定为2个，实现过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;  </span><br><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, _1, _2, <span class="number">5</span>); <span class="comment">//_1，_2是占位符，固定num=5 </span></span><br><span class="line">new_fun(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(*<span class="built_in">array</span>)); <span class="comment">// 调用只需要2个参数了</span></span><br></pre></td></tr></table></figure><p>上面代码中_1，_2是占位符，定义于命名空间<code>placeholders</code>中，_1是n<code>new_fun</code>的第一个参数，_2是<code>new_fun</code>的第二个参数，以此类推。在本例中，<code>fun()</code>的调用需要传递三个参数，而用<code>bind()</code>进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是<code>bind</code>最常见的用法。</p><h3 id="用法二：更改参数的顺序"><a href="#用法二：更改参数的顺序" class="headerlink" title="用法二：更改参数的顺序"></a>用法二：更改参数的顺序</h3><p> <code>bind</code>的另一个常见的用法是更改参数的调用顺序，如 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, _2, _1);</span><br></pre></td></tr></table></figure><p> 此时，调用<code>new_fun(1, 2)</code>相当于调用<code>fun(2, 1)</code>。 </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::bind&lt;/code&gt;包含在标准库头文件&lt;code&gt;#include&amp;lt;functional&amp;gt;&lt;/code&gt;中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="std::bind" scheme="http://example.com/tags/std-bind/"/>
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::function用法总结</title>
    <link href="http://example.com/2021/04/28/210428_cpp_std_function/"/>
    <id>http://example.com/2021/04/28/210428_cpp_std_function/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-05T08:49:04.996Z</updated>
    
    <content type="html"><![CDATA[<p>关于标准库中的<code>std::function</code>类模板，在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>官方给出的解释是</p><blockquote><p>Class template <code>std::function</code> is a general-purpose polymorphic function wrapper. Instances of <code>std::function</code> can store, copy, and invoke any <code>CopyConstructible</code> <code>Callable</code> target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.</p></blockquote><a id="more"></a><p>中文的意思是：类模板<code>std::function</code>是一种通用的多态函数封装，<code>std::function</code>的实例可以对任何<code>CopyConstructible Callable</code><strong>目标</strong>进行存储、复制和调用操作，这些<strong>目标</strong>可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。<code>std::function</code>对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。</p><p>比较通俗的理解就是，通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的<code>std::function</code>对象，让我们不需要再纠结那么多的可调用实体。</p><h2 id="对函数的封装"><a href="#对函数的封装" class="headerlink" title="对函数的封装"></a>对函数的封装</h2><p>定义一个实现加法的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将其封装为一个function类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_add = add;</span><br></pre></td></tr></table></figure><p>用下面的方式对<code>f_add</code>实体对象进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_add(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 结果将返回9</span></span><br></pre></td></tr></table></figure><h2 id="对函数类-结构体的封装"><a href="#对函数类-结构体的封装" class="headerlink" title="对函数类/结构体的封装"></a>对函数类/结构体的封装</h2><p>定义一个除法的结构体或者类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_div</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a / b; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将其封装为一个function对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_div = my_div();</span><br></pre></td></tr></table></figure><p>同样的，调用形式和上面的<code>f_add</code>一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_div(<span class="number">6</span>, <span class="number">2</span>); <span class="comment">// 执行完result结果为3</span></span><br></pre></td></tr></table></figure><h2 id="对Lambda表达式的封装"><a href="#对Lambda表达式的封装" class="headerlink" title="对Lambda表达式的封装"></a>对Lambda表达式的封装</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。</p><p>Lambda表达式的完整声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p> 各项具体含义如下 </p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了返回值类型，编译器可以自动推断。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了参数列表，类似普通函数中的无参函数。</span></span><br><span class="line">[capture <span class="built_in">list</span>] &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>让我们来看个例子，现在假设我们有一个无序的<code>vector</code>变量，我们想用C++标准库中的<code>sort</code>函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>sort</code>函数，旧式的做法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(), cmp);<span class="comment">// myvec是一个int类型的无序变量</span></span><br></pre></td></tr></table></figure><p>现在可以方便地利用Lambda表达式来简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span> &#123;<span class="keyword">return</span> a &lt; b;&#125;);</span><br></pre></td></tr></table></figure><p>值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[x, y…]</td><td>默认以值的形式捕获指定的多个外部变量（用逗号分隔）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><p>如果我们需要修改捕获变量，这时需要利用<code>mutable</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; ++a; &#125;; <span class="comment">// 执行完后a=101</span></span><br></pre></td></tr></table></figure><h3 id="封装Lambda表达式"><a href="#封装Lambda表达式" class="headerlink" title="封装Lambda表达式"></a>封装Lambda表达式</h3><p>现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_mul = [](<span class="keyword">double</span> x, <span class="keyword">double</span> y) &#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用<code>std::function</code>实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculator</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面已经定义的<code>f_add</code>对象作为参数传入<code>calculator()</code>函数中，在内部进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = calculator(<span class="number">4</span>, <span class="number">5</span>, f_add);</span><br></pre></td></tr></table></figure><p>这样我们就实现了函数的回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的例子，我们学会了如何使用标准库中的<code>std::function</code>模板类对函数对象进行封装，从而可以统一成一种形式的调用，在最后我们还学习了如何将<code>std::function</code>类作为函数的参数，来实现回调函数的功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于标准库中的&lt;code&gt;std::function&lt;/code&gt;类模板，在&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/function&quot;&gt;cppreference&lt;/a&gt;官方给出的解释是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Class template &lt;code&gt;std::function&lt;/code&gt; is a general-purpose polymorphic function wrapper. Instances of &lt;code&gt;std::function&lt;/code&gt; can store, copy, and invoke any &lt;code&gt;CopyConstructible&lt;/code&gt; &lt;code&gt;Callable&lt;/code&gt; target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="std::function" scheme="http://example.com/tags/std-function/"/>
    
    <category term="lambda表达式" scheme="http://example.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
