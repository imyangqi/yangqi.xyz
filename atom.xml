<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>时间之矢</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-10-08T06:29:11.672Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>杨琦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>假期里一些散落的念想</title>
    <link href="http://example.com/2021/10/08/211008_diary_national_day/"/>
    <id>http://example.com/2021/10/08/211008_diary_national_day/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T06:29:11.672Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间工作很忙，又是出差又是赶新版本发布，连续加班了好多天，感觉很累，所以趁着国庆假期多请了两天假，加上原本的周日，一共就有了10天的假期，打算回家好好休息一下。<a id="more"></a>这次回家家里只有我和外公外婆三个人，妹妹和爸妈都没有回来。我抽时间去探望我的爷爷奶奶，还有肝癌晚期的二爷爷，还去参加了两场同学的婚礼。</p><p>昨天整理了账本，很认真地计算了自己当前的财产状况，发现现在已经是负债状态，借了很多钱给别人，有的算利息，有的不算利息，还款要等很久，有的欠款甚至可能收不回来。我总是容易把人想得过于单纯，以为所有人都会言而有信，所有人都像自己一样善良。这确实让我结识了很多好人，但毫无防备地去信任他人也让自己多次陷入到很困难的局面。我以后应该更加谨慎一些。</p><p>在家吃的饭菜都是外公外婆自己种的，有很多蔬菜：小白菜、茄子、土豆丝，和肉一起炒，被外公外婆做的很好吃，我很喜欢。我的胃似乎很喜欢吃家里的饭，都没有拉过肚子，吃公司的饭菜就很容易吃坏肚子。我应该想一些办法自己弄吃的，每天吃公司点的饭菜太不健康了。</p><p>还有关于跑步，刚回家的两天每天早上起来跑步，后来就没有跑了，一方面是因为公路的扬尘有点多，还有一方面是因为早上有些天有事需要我帮忙。不过回广州以后，我还是打算要经常跑步，不一定要每天，但要持续地坚持跑下去。</p><p>原本假期计划了一些学习任务，但除了在回家的时候在高铁上看了几集视频课程，其它时间就再也没有学习了，一直持续到了现在，想要靠假期一个人高强度地进行学习，我还是太天真了。关于学习，这也一直是我所焦虑的事情，工作后我发现自己所欠缺的知识太多了，虽然在工作中能不断通过实战累积一些知识，但如果想要成为一名优秀的CAE研发工程师，只靠工作中的知识积累是远远不够的，还要有很扎实的电磁场理论基础、数学计算方法、编程技巧、计算机理论知识等等，这些都需要自己在下班时间不断学习，练习，和总结。</p><p>关于恋爱和婚姻，身边很多同学都陆续结婚了，没有结婚的大多数也都有了很稳定的伴侣。父母和老人都在催促自己赶紧找一个，早点结婚生子。想要找一个自己喜欢的，并且也喜欢自己的人真的好难，工作和学习已经花掉了我大部分的时间，剩下的时间还要用来锻炼、阅读，就更没有时间进行社交了。前段时间还在知乎上发了相亲贴，加了一位女生，但基本上每天都是我主动聊天，几天后累了，放弃了，相亲贴删了。爱情还是要看缘分，就这样吧。</p><p>假期休息了这么久，我又要重新起航了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前段时间工作很忙，又是出差又是赶新版本发布，连续加班了好多天，感觉很累，所以趁着国庆假期多请了两天假，加上原本的周日，一共就有了10天的假期，打算回家好好休息一下。</summary>
    
    
    
    <category term="我的日记" scheme="http://example.com/categories/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/"/>
    
    
    <category term="假期" scheme="http://example.com/tags/%E5%81%87%E6%9C%9F/"/>
    
    <category term="家乡" scheme="http://example.com/tags/%E5%AE%B6%E4%B9%A1/"/>
    
  </entry>
  
  <entry>
    <title>四面体上的高斯积分</title>
    <link href="http://example.com/2021/10/08/tetra_integral/"/>
    <id>http://example.com/2021/10/08/tetra_integral/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T14:12:37.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设\(f_1\left( \boldsymbol{x} \right) \)和\(f_2\left( \boldsymbol{x} \right) \)分别为定义在两个相邻四面体内的函数，其表达式为： </p><div>$$f_1\left(\boldsymbol{x} \right) =2x+4y+z,\\f_2\left(\boldsymbol{x}\right) =3x+2y^2-zy.$$</div><p>现需要计算的面积分项为： </p><div>$$I=\int_{\partial \varOmega _k}{f_1\left( \boldsymbol{x} \right) \frac{\partial f_2\left( \boldsymbol{x} \right)}{\partial y}}d\boldsymbol{x}.$$</div>其中\(\partial \varOmega _k\) 表示在第 \(k\)个四面体上的边界面。<p>不失一般性，定义两个如下图所示的两个相邻四面体\(\Omega _1\) 和\(\Omega _2\) ：</p><center class="half"><img src="/images/article/tetra_quad/two_tetra_elems.jpg" alt="相邻两个四面体"  width="600"/></center>计算：两个四面体的交界面上的面积分。<h2 id="方案1：直接积分"><a href="#方案1：直接积分" class="headerlink" title="方案1：直接积分"></a>方案1：直接积分</h2><p>由于函数表达式已知，我们可以直接得到</p><div>$$\frac{\partial f_2\left( \boldsymbol{x} \right)}{\partial y}=4y-z.$$</div><p>直接运用高斯积分，原来的积分项可以简化为：</p><div>$$I=\int_{\partial \varOmega _k}{f_1\left( \boldsymbol{x} \right) \frac{\partial f_2\left( \boldsymbol{x} \right)}{\partial y}}d\boldsymbol{x}=\sum_{k=1}^N{f_1\left( \boldsymbol{x}_k \right) \frac{\partial f_2\left( \boldsymbol{x}_k \right)}{\partial y}w_k}.$$</div>其中，\(\boldsymbol{x}_k\) 为计算区域上的高斯积分点，\(w_k\) 为对应高斯积分点的权。计算结果为：-0.166667。<h2 id="方案2：坐标映射积分"><a href="#方案2：坐标映射积分" class="headerlink" title="方案2：坐标映射积分"></a>方案2：坐标映射积分</h2><h3 id="参考四面体"><a href="#参考四面体" class="headerlink" title="参考四面体"></a>参考四面体</h3><p>首先，在局部坐标系下定义如下图所示的参考四面体：</p><center class="half"><img src="/images/article/tetra_quad/ref_tetra.jpg" alt="参考四面体"  width="500"/></center><p>从任意四面体\(\Omega _k\)到参考四面体的映射关系为：</p><div>$$\boldsymbol{x}=-\frac{r+s+t+1}{2}\boldsymbol{v}_{1}^{k}+\frac{r+1}{2}\boldsymbol{v}_{2}^{k}+\frac{s+1}{2}\boldsymbol{v}_{3}^{k}+\frac{t+1}{2}\boldsymbol{v}_{4}^{k}=\varPsi \left( \boldsymbol{r} \right) $$</div><p>很容易检验上式只要代入在 \(\left(r,s,t\right)\) 坐标系下的参考四面体的四个顶点坐标，得到的就是实际四面体在 \(\left(x,y,z\right)\) 坐标系下的四个顶点坐标。</p><h3 id="雅可比映射"><a href="#雅可比映射" class="headerlink" title="雅可比映射"></a>雅可比映射</h3><p>从实际四面体到参考四面体的映射为线性映射，映射之间的雅可比系数满足如下关系：</p><div>$$\frac{\partial \boldsymbol{x}}{\partial \boldsymbol{r}}\frac{\partial \boldsymbol{r}}{\partial \boldsymbol{x}}=\left[ \begin{matrix}    x_r&        x_s&        x_t\\    y_r&        y_s&        y_t\\    z_r&        z_s&        z_t\\\end{matrix} \right] \left[ \begin{matrix}    r_x&        r_y&        r_z\\    s_x&        s_y&        s_z\\    t_x&        t_y&        t_z\\\end{matrix} \right] =\left[ \begin{matrix}    1&        0&        0\\    0&        1&        0\\    0&        0&        1\\\end{matrix} \right] ,J=\det \left( \frac{\partial \boldsymbol{x}}{\partial \boldsymbol{r}} \right) .$$</div><p>其中\(J\)为雅可比矩阵行列式的值，可以通过映射的函数关系\(\boldsymbol{x}=\varPsi \left( \boldsymbol{r} \right)\)求出。<br>因此通过求雅可比矩阵的逆和左乘一个单元矩阵，容易就求出\(r_x,r_y,r_z\)等系数。</p><h3 id="求导链法则"><a href="#求导链法则" class="headerlink" title="求导链法则"></a>求导链法则</h3><p>由于函数\(f_2(\boldsymbol{x})\) 是定义在四面体\(\Omega _2\)上的函数，根据求导链法则可以得到：</p><div>$$\frac{\partial f_2\left( \boldsymbol{x} \right)}{\partial y}=\frac{\partial f_2\left( \boldsymbol{r} \right)}{\partial r}\frac{\partial r}{\partial y}+\frac{\partial f_2\left( \boldsymbol{r} \right)}{\partial s}\frac{\partial s}{\partial y}+\frac{\partial f_2\left( \boldsymbol{r} \right)}{\partial t}\frac{\partial t}{\partial y}.$$</div><p>根据上述的映射关系，有：</p><div>$$x=-0.5\left( r+s+t+1 \right) x_1+0.5\left( r+1 \right) x_2+0.5\left( s+1 \right) x_3+0.5\left( t+1 \right) x_4, \\y=-0.5\left( r+s+t+1 \right) y_1+0.5\left( r+1 \right) y_2+0.5\left( s+1 \right) y_3+0.5\left( t+1 \right) y_4, \\z=-0.5\left( r+s+t+1 \right) z_1+0.5\left( r+1 \right) z_2+0.5\left( s+1 \right) z_3+0.5\left( t+1 \right) z_4.$$</div><p>代入\(\Omega _2\)的四个顶点坐标，易得：</p><div>$$x=0.5\left( s-r \right) ,y=-0.5\left( t+1 \right) ,z=-0.5\left( r+s+t+1 \right) .$$</div><p>在参考四面体下的函数\(f_2\left( \boldsymbol{r} \right)\)可以表示为：</p><div>$$f_2\left( \boldsymbol{r} \right) =3x\left( \boldsymbol{r} \right) +2y\left( \boldsymbol{r} \right) ^2-z\left( \boldsymbol{r} \right) y\left( \boldsymbol{r} \right) \,\,\\=1.5\left( s-r \right) +0.5\left( t+1 \right) ^2-0.25\left( t+1 \right) \left( r+s+t+1 \right) $$</div><p>对于的偏导项分别为：</p><div>$$\frac{\partial f_2\left( \boldsymbol{r} \right)}{\partial r}=-1.5-0.25\left( t+1 \right) ,\\\frac{\partial f_2\left( \boldsymbol{r} \right)}{\partial s}=1.5-0.25\left( t+1 \right) ,\\\frac{\partial f_2\left( \boldsymbol{r} \right)}{\partial t}=0.5\left( t+1 \right) -0.25\left( r+s \right) .$$</div><p>通过雅可比矩阵可以计算出系数：\(r_y=1,s_y=1,t_y=-2.\)<br>对积分而言，我们可以将其简化为：</p><div>$$I_2=J_{f}^{k}\int_{\partial \varOmega _k}{f_1\left( \boldsymbol{r} \right) \left( \frac{\partial f_2\left( \boldsymbol{r}^+ \right)}{\partial r}\frac{\partial r}{\partial y}+\frac{\partial f_2\left( \boldsymbol{r}^+ \right)}{\partial s}\frac{\partial s}{\partial y}+\frac{\partial f_2\left( \boldsymbol{r}^+ \right)}{\partial t}\frac{\partial t}{\partial y} \right)}dS.$$</div><p>其中面上的雅可比系数\(J{f}^{k}\)为实际面与映射面的面积之比。</p><h3 id="积分点匹配"><a href="#积分点匹配" class="headerlink" title="积分点匹配"></a>积分点匹配</h3><p>注意到\(\Omega _1\)在交界面上是映射到参考单元 \((\boldsymbol{v_2,v_3,v_4})\) 构成的面，而\(\Omega _2\)是映射到\((\boldsymbol{v_2,v_3,v_4})\)所构成的面。由于我们是预先在参考四面体上生成了高斯积分点，当想采用高斯积分来求解的时候，需要在两个面之间做一个高斯积分点匹配的过程。例如，如下图所示，在左边的四面体上交界面映射到的是参考单元的\((\boldsymbol{v_2,v_3,v_4})\)面，右边四面体的交界面映射到的是参考单元的\((\boldsymbol{v_1,v_3,v_4})\)面，实际交界面上的同一个点由左边的四面体映射到的是一个面上的 3 号积分点，而右边四面体映射到的是另一个面上的 5 号积分点。我们可以选择在两个面上的任意一个面做积分，只是不同面上的雅可比系数\(J_{f}^{k}\)有所不同。</p><center class="half"><img src="/images/article/tetra_quad/tetra_mapping.jpg" alt="积分点匹配示意图"  width="600"/></center><p>在本文中以第一个四面体\(\Omega _1\)在交界面映射到参考单元的 \((\boldsymbol{v_2,v_3,v_4})\) 面为积分面，对\(\Omega _2\)映射到第\((\boldsymbol{v_1,v_2,v_3})\)面做高斯积分点匹配，结果如下图所示。</p><center class="half"><img src="/images/article/tetra_quad/quad_match.jpg" alt="积分点匹配示意图"  width="600"/></center><h3 id="最后求解"><a href="#最后求解" class="headerlink" title="最后求解"></a>最后求解</h3><p>通过求雅可比系数和建立高斯积分点匹配表，我们可以最后求解得到该面积分的值为−0.166667，和方案1是一致的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对比两种高斯积分方案，验证了参考四面体上进行积分映射可以得到实际四面体上的积分。这样做的好处是，在有限元算法中我们只需要存储一个参考四面体上的矩阵和一些与实际四面体相关的雅可比系数，而不需要对实际中每一个四面体都存矩阵，这样就实现了低存储的方案。</p><h2 id="附录：C-代码"><a href="#附录：C-代码" class="headerlink" title="附录：C++代码"></a>附录：C++代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;Eigen&#x2F;dense&gt;</span><br><span class="line">using namespace Eigen;</span><br><span class="line">using namespace std;</span><br><span class="line">#define Length(a) (sizeof(a)&#x2F;sizeof(a[0]))</span><br><span class="line"></span><br><span class="line">&#x2F;* 2D *&#x2F;</span><br><span class="line">#define Perm3(a)    double(a),double(a),double(a)</span><br><span class="line">#define Dup3(w)     w</span><br><span class="line">#define Perm21(a)   double(1.)-a-a,a,a, </span><br><span class="line"> a,double(1.)-a-a,a, </span><br><span class="line"> a,a,double(1.)-a-a</span><br><span class="line">#define Dup21(w)   w,w,w</span><br><span class="line">#define Perm111(a,b)    a,b,double(1.)-a-b, </span><br><span class="line"> a,double(1.)-a-b,b, </span><br><span class="line"> b,a,double(1.)-a-b, </span><br><span class="line"> b,double(1.)-a-b,a, </span><br><span class="line"> double(1.)-a-b,a,b, </span><br><span class="line"> double(1.)-a-b,b,a</span><br><span class="line">#define Dup111(w)  w,w,w,w,w,w</span><br><span class="line"></span><br><span class="line">double QUAD_2D_P15_wts[] &#x3D; &#123;</span><br><span class="line">    Dup3(.02357126703190634206659321140821418),</span><br><span class="line">  Dup21(.01517314955721170450311858877690239),</span><br><span class="line"> Dup21(.01297600128392884154979521077280757),</span><br><span class="line"> Dup21(.01706629596800615670942600046160914),</span><br><span class="line"> Dup21(.04576001946273760698482638108892258),</span><br><span class="line"> Dup111(.00222757447282223154006065426298478),</span><br><span class="line">    Dup111(.02701014165986947101315702212247500),</span><br><span class="line">    Dup111(.02608377963958756403057720483642768),</span><br><span class="line">    Dup111(.01211015327702828337230795926322736),</span><br><span class="line">    Dup111(.01564785059680444573399007149035058),</span><br><span class="line">    Dup111(.03417088937929479242522512890637806)</span><br><span class="line">&#125;;</span><br><span class="line">double QUAD_2D_P15_pts[Length(QUAD_2D_P15_wts) * 3] &#x3D; &#123;</span><br><span class="line">  Perm3(.33333333333333333333333333333333333),</span><br><span class="line"> Perm21(.11022229622834687297855264132259850),</span><br><span class="line">    Perm21(.05197643301003435047003197947889073),</span><br><span class="line">    Perm21(.49114565807532554119014945122395425),</span><br><span class="line">    Perm21(.39315718888435884048226809785071794),</span><br><span class="line">    Perm111(.03737440487572919066543605209836625,</span><br><span class="line">        .96251835223001214880811969560396873),</span><br><span class="line">   Perm111(.24824877798467321198263980694374938,</span><br><span class="line">        .19316669854521416819773100288721521),</span><br><span class="line">   Perm111(.20699402274830217740486528153682148,</span><br><span class="line">        .08689590883549962551575259619781217),</span><br><span class="line">   Perm111(.14854110526954708137688902238435510,</span><br><span class="line">        .01743682539845430796259020511767948),</span><br><span class="line">   Perm111(.30674237923596382376588728350286621,</span><br><span class="line">        .01749251095825766163254977051260599),</span><br><span class="line">   Perm111(.36703198754220473278855469116984882,</span><br><span class="line">        .09034802175864556044634095119222305)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Real_Quad_Pts_2D(double **p, double x[], double y[], double z[]);</span><br><span class="line">void Area_face(double *Area, double x[], double y[], double z[]);</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; elem1</span><br><span class="line"> double x_elem1[4] &#x3D; &#123; 0, 1,-1, 0 &#125;;</span><br><span class="line">  double y_elem1[4] &#x3D; &#123; 1, 0, 0, 0 &#125;;</span><br><span class="line">  double z_elem1[4] &#x3D; &#123; 0, 0, 0, 1 &#125;;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; elem2</span><br><span class="line"> double x_elem2[4] &#x3D; &#123; 0,-1, 1, 0 &#125;;</span><br><span class="line">  double y_elem2[4] &#x3D; &#123; 0, 0, 0,-1 &#125;;</span><br><span class="line">  double z_elem2[4] &#x3D; &#123; 1, 0, 0, 0 &#125;;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; guass integral order                    </span><br><span class="line">  int order &#x3D; 15; </span><br><span class="line"> int quad_num_2D &#x3D; 49;</span><br><span class="line">    double Area[4];</span><br><span class="line">  double *quad_2D_wts &#x3D; QUAD_2D_P15_wts;</span><br><span class="line">   double **quad_pts_face &#x3D; new double *[12];</span><br><span class="line">   for (int i &#x3D; 0; i &lt; 12; ++i) &#123;</span><br><span class="line">        quad_pts_face[i] &#x3D; new double[quad_num_2D]; </span><br><span class="line"> &#125;</span><br><span class="line">    &#x2F;&#x2F; the interface between two tetrahedrons is face[2]</span><br><span class="line"> Area_face(Area, x_elem1, y_elem1, z_elem1);</span><br><span class="line">  Real_Quad_Pts_2D(quad_pts_face, x_elem1, y_elem1, z_elem1);</span><br><span class="line">  </span><br><span class="line"> &#x2F;&#x2F; plan A</span><br><span class="line">    double *f1 &#x3D; new double[quad_num_2D];</span><br><span class="line">    double *f2 &#x3D; new double[quad_num_2D];</span><br><span class="line">    double *dyf2 &#x3D; new double[quad_num_2D];</span><br><span class="line">  int idxface &#x3D; 2;</span><br><span class="line"> for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       double x &#x3D; quad_pts_face[idxface * 3][i];</span><br><span class="line">        double y &#x3D; quad_pts_face[idxface * 3 + 1][i];</span><br><span class="line">        double z &#x3D; quad_pts_face[idxface * 3 + 2][i];</span><br><span class="line">        f1[i] &#x3D; 2 * x + 4 * y + z;</span><br><span class="line">       f2[i] &#x3D; 3 * x + 2 * y * y - z * y;</span><br><span class="line">       dyf2[i] &#x3D; 4 * y - z;</span><br><span class="line"> &#125;</span><br><span class="line">    double result1 &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       result1 +&#x3D; f1[i] * dyf2[i] * quad_2D_wts[i] * Area[idxface];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; plan B</span><br><span class="line">    &#x2F;&#x2F; reference element</span><br><span class="line"> double x_ref[4] &#x3D; &#123; -1,1,-1,-1 &#125;;</span><br><span class="line">    double y_ref[4] &#x3D; &#123; -1,-1,1,-1 &#125;;</span><br><span class="line">    double z_ref[4] &#x3D; &#123; -1,-1,-1,1 &#125;;</span><br><span class="line">    double **quad_pts_face_ref &#x3D; new double *[12];</span><br><span class="line">   for (int i &#x3D; 0; i &lt; 12; ++i) &#123;</span><br><span class="line">        quad_pts_face_ref[i] &#x3D; new double[quad_num_2D];</span><br><span class="line">  &#125;</span><br><span class="line">    double Area_ref[4];</span><br><span class="line">  Area_face(Area_ref, x_ref, y_ref, z_ref);</span><br><span class="line">    Real_Quad_Pts_2D(quad_pts_face_ref, x_ref, y_ref, z_ref);</span><br><span class="line">    double *f1_ref &#x3D; new double[quad_num_2D];</span><br><span class="line">    double *drf2 &#x3D; new double[quad_num_2D];</span><br><span class="line">  double *dsf2 &#x3D; new double[quad_num_2D];</span><br><span class="line">  double *dtf2 &#x3D; new double[quad_num_2D];</span><br><span class="line">  double *quad_2D_wts_ref &#x3D; QUAD_2D_P15_wts;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; r s t to x y z on gauss integral point</span><br><span class="line">    int idxface1 &#x3D; 2; int idxface2 &#x3D; 0;</span><br><span class="line">  VectorXd r1 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd s1 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd t1 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd r2 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd s2 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd t2 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       r1[i] &#x3D; quad_pts_face_ref[idxface1 * 3][i];</span><br><span class="line">      s1[i] &#x3D; quad_pts_face_ref[idxface1 * 3 + 1][i];</span><br><span class="line">      t1[i] &#x3D; quad_pts_face_ref[idxface1 * 3 + 2][i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       r2[i] &#x3D; quad_pts_face_ref[idxface2 * 3][i];</span><br><span class="line">      s2[i] &#x3D; quad_pts_face_ref[idxface2 * 3 + 1][i];</span><br><span class="line">      t2[i] &#x3D; quad_pts_face_ref[idxface2 * 3 + 2][i];</span><br><span class="line">  &#125;</span><br><span class="line">    VectorXd x1 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd y1 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd z1 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd x2 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd y2 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line">   VectorXd z2 &#x3D; VectorXd::Zero(quad_num_2D);</span><br><span class="line"></span><br><span class="line">    VectorXd OnesNp &#x3D; VectorXd::Ones(quad_num_2D);</span><br><span class="line"></span><br><span class="line">    x1 &#x3D; 0.5*(-(OnesNp + r1 + s1 + t1)*x_elem1[0] + (OnesNp + r1)*x_elem1[1] + (OnesNp + s1)*x_elem1[2] + (OnesNp + t1)*x_elem1[3]);</span><br><span class="line"> y1 &#x3D; 0.5*(-(OnesNp + r1 + s1 + t1)*y_elem1[0] + (OnesNp + r1)*y_elem1[1] + (OnesNp + s1)*y_elem1[2] + (OnesNp + t1)*y_elem1[3]);</span><br><span class="line"> z1 &#x3D; 0.5*(-(OnesNp + r1 + s1 + t1)*z_elem1[0] + (OnesNp + r1)*z_elem1[1] + (OnesNp + s1)*z_elem1[2] + (OnesNp + t1)*z_elem1[3]);</span><br><span class="line">     </span><br><span class="line">     x2 &#x3D; 0.5*(-(OnesNp + r2 + s2 + t2)*x_elem2[0] + (OnesNp + r2)*x_elem2[1] + (OnesNp + s2)*x_elem2[2] + (OnesNp + t2)*x_elem2[3]);</span><br><span class="line">     y2 &#x3D; 0.5*(-(OnesNp + r2 + s2 + t2)*y_elem2[0] + (OnesNp + r2)*y_elem2[1] + (OnesNp + s2)*y_elem2[2] + (OnesNp + t2)*y_elem2[3]);</span><br><span class="line">     z2 &#x3D; 0.5*(-(OnesNp + r2 + s2 + t2)*z_elem2[0] + (OnesNp + r2)*z_elem2[1] + (OnesNp + s2)*z_elem2[2] + (OnesNp + t2)*z_elem2[3]);</span><br><span class="line"></span><br><span class="line">  double tol &#x3D; 1e-8;</span><br><span class="line">   VectorXi VmapP &#x3D; VectorXi::Zero(quad_num_2D);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       VmapP[i] &#x3D; i;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; quad_num_2D; ++j) &#123;</span><br><span class="line">           double distmp &#x3D; sqrt((x1[i] - x2[j])*(x1[i] - x2[j]) </span><br><span class="line">                + (y1[i] - y2[j])*(y1[i] - y2[j]) </span><br><span class="line">               + (z1[i] - z2[j])*(z1[i] - z2[j]));</span><br><span class="line">          if (distmp &lt; tol) &#123;</span><br><span class="line">               VmapP[i] &#x3D; j; break;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> double sJ &#x3D; Area[idxface1] &#x2F; Area_ref[idxface1];</span><br><span class="line"> double ry &#x3D; 1, sy &#x3D; 1, ty &#x3D; -2;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       double r_1 &#x3D; quad_pts_face_ref[idxface1 * 3][i];</span><br><span class="line">     double s_1 &#x3D; quad_pts_face_ref[idxface1 * 3 + 1][i];</span><br><span class="line">     double t_1 &#x3D; quad_pts_face_ref[idxface1 * 3 + 2][i];</span><br><span class="line">     double r_2 &#x3D; quad_pts_face_ref[idxface2 * 3][VmapP[i]];</span><br><span class="line">      double s_2 &#x3D; quad_pts_face_ref[idxface2 * 3 + 1][VmapP[i]];</span><br><span class="line">      double t_2 &#x3D; quad_pts_face_ref[idxface2 * 3 + 2][VmapP[i]];</span><br><span class="line">      drf2[i] &#x3D; -1.5 - 0.25*(t_2 + 1);</span><br><span class="line">     dsf2[i] &#x3D;  1.5 - 0.25*(t_2 + 1);</span><br><span class="line">     dtf2[i] &#x3D; 0.5*(t_2 + 1) - 0.25*(r_2 + s_2);</span><br><span class="line">      f1_ref[i] &#x3D; (-r_1 - 3 * s_1 - 1.5*t_1 - 1.5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> double result2 &#x3D; 0;</span><br><span class="line">  for (int i &#x3D; 0; i &lt; quad_num_2D; ++i) &#123;</span><br><span class="line">       result2 +&#x3D; f1_ref[i] * (drf2[i] * ry + dsf2[i] * sy </span><br><span class="line">         + dtf2[i] * ty) * quad_2D_wts[i] * Area_ref[idxface1];</span><br><span class="line">   &#125;</span><br><span class="line">    cout &lt;&lt; &quot; result1 &#x3D; &quot; &lt;&lt; result1 &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; &quot; result2 &#x3D; &quot; &lt;&lt; result2*sJ &lt;&lt; endl;</span><br><span class="line">   system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Real_Quad_Pts_2D(double **p, double x[], double y[], double z[])</span><br><span class="line">&#123;</span><br><span class="line">  int  Num_of_Quad &#x3D; 49, i;</span><br><span class="line">    double *quad_2D_pts &#x3D; 0;</span><br><span class="line"> quad_2D_pts &#x3D; QUAD_2D_P15_pts;</span><br><span class="line">   double x_f[3], y_f[3], z_f[3];</span><br><span class="line">   </span><br><span class="line"> &#x2F;&#x2F;face 1:1 2 3</span><br><span class="line">   x_f[0] &#x3D; x[0];  x_f[1] &#x3D; x[1];  x_f[2] &#x3D; x[2];</span><br><span class="line">   y_f[0] &#x3D; y[0];  y_f[1] &#x3D; y[1];  y_f[2] &#x3D; y[2];</span><br><span class="line">   z_f[0] &#x3D; z[0];  z_f[1] &#x3D; z[1];  z_f[2] &#x3D; z[2];</span><br><span class="line">   for (i &#x3D; 0; i &lt; Num_of_Quad; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">        p[0][i] &#x3D; x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[1][i] &#x3D; y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[2][i] &#x3D; z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;face 2:1 2 4</span><br><span class="line">   x_f[0] &#x3D; x[0]; x_f[1] &#x3D; x[1]; x_f[2] &#x3D; x[3];  y_f[0] &#x3D; y[0]; y_f[1] &#x3D; y[1]; y_f[2] &#x3D; y[3]; z_f[0] &#x3D; z[0]; z_f[1] &#x3D; z[1]; z_f[2] &#x3D; z[3];</span><br><span class="line">  for (i &#x3D; 0; i &lt; Num_of_Quad; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">        p[3][i] &#x3D; x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[4][i] &#x3D; y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[5][i] &#x3D; z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;face 3:2 3 4</span><br><span class="line">   x_f[0] &#x3D; x[1]; x_f[1] &#x3D; x[2]; x_f[2] &#x3D; x[3];  y_f[0] &#x3D; y[1]; y_f[1] &#x3D; y[2]; y_f[2] &#x3D; y[3]; z_f[0] &#x3D; z[1]; z_f[1] &#x3D; z[2]; z_f[2] &#x3D; z[3];</span><br><span class="line">  for (i &#x3D; 0; i &lt; Num_of_Quad; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">        p[6][i] &#x3D; x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[7][i] &#x3D; y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[8][i] &#x3D; z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;face 4:1 3 4</span><br><span class="line">   x_f[0] &#x3D; x[0]; x_f[1] &#x3D; x[2]; x_f[2] &#x3D; x[3];  y_f[0] &#x3D; y[0]; y_f[1] &#x3D; y[2]; y_f[2] &#x3D; y[3]; z_f[0] &#x3D; z[0]; z_f[1] &#x3D; z[2]; z_f[2] &#x3D; z[3];</span><br><span class="line">  for (i &#x3D; 0; i &lt; Num_of_Quad; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">        p[9][i] &#x3D; x_f[0] * quad_2D_pts[3 * i] + x_f[1] * quad_2D_pts[3 * i + 1] + x_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">       p[10][i] &#x3D; y_f[0] * quad_2D_pts[3 * i] + y_f[1] * quad_2D_pts[3 * i + 1] + y_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">      p[11][i] &#x3D; z_f[0] * quad_2D_pts[3 * i] + z_f[1] * quad_2D_pts[3 * i + 1] + z_f[2] * quad_2D_pts[3 * i + 2];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Area_face(double *Area, double x[], double y[], double z[])</span><br><span class="line">&#123;</span><br><span class="line">    double Len[3], x_f[3], y_f[3], z_f[3];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;face 1:1 2 3</span><br><span class="line">   x_f[0] &#x3D; x[0]; x_f[1] &#x3D; x[1]; x_f[2] &#x3D; x[2];</span><br><span class="line"> y_f[0] &#x3D; y[0]; y_f[1] &#x3D; y[1]; y_f[2] &#x3D; y[2];</span><br><span class="line"> z_f[0] &#x3D; z[0]; z_f[1] &#x3D; z[1]; z_f[2] &#x3D; z[2];</span><br><span class="line"></span><br><span class="line">  Len[0] &#x3D; sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0));</span><br><span class="line">  Len[1] &#x3D; sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0));</span><br><span class="line">  Len[2] &#x3D; sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0));</span><br><span class="line"></span><br><span class="line">   Area[0] &#x3D; sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])*</span><br><span class="line">     (Len[1] + Len[2] - Len[0])) &#x2F; 4;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;face 2:1 2 4</span><br><span class="line">   x_f[0] &#x3D; x[0]; x_f[1] &#x3D; x[1]; x_f[2] &#x3D; x[3];</span><br><span class="line"> y_f[0] &#x3D; y[0]; y_f[1] &#x3D; y[1]; y_f[2] &#x3D; y[3];</span><br><span class="line"> z_f[0] &#x3D; z[0]; z_f[1] &#x3D; z[1]; z_f[2] &#x3D; z[3];</span><br><span class="line"></span><br><span class="line">  Len[0] &#x3D; sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0));</span><br><span class="line">  Len[1] &#x3D; sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0));</span><br><span class="line">  Len[2] &#x3D; sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0));</span><br><span class="line"></span><br><span class="line">   Area[1] &#x3D; sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])*</span><br><span class="line">     (Len[1] + Len[2] - Len[0])) &#x2F; 4;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;face 3:2 3 4</span><br><span class="line">   x_f[0] &#x3D; x[1]; x_f[1] &#x3D; x[2]; x_f[2] &#x3D; x[3];</span><br><span class="line"> y_f[0] &#x3D; y[1]; y_f[1] &#x3D; y[2]; y_f[2] &#x3D; y[3];</span><br><span class="line"> z_f[0] &#x3D; z[1]; z_f[1] &#x3D; z[2]; z_f[2] &#x3D; z[3];</span><br><span class="line"></span><br><span class="line">  Len[0] &#x3D; sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0));</span><br><span class="line">  Len[1] &#x3D; sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0));</span><br><span class="line">  Len[2] &#x3D; sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0));</span><br><span class="line"></span><br><span class="line">   Area[2] &#x3D; sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])*</span><br><span class="line">     (Len[1] + Len[2] - Len[0])) &#x2F; 4;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;face 4:1 3 4</span><br><span class="line">   x_f[0] &#x3D; x[0]; x_f[1] &#x3D; x[2]; x_f[2] &#x3D; x[3];</span><br><span class="line"> y_f[0] &#x3D; y[0]; y_f[1] &#x3D; y[2]; y_f[2] &#x3D; y[3];</span><br><span class="line"> z_f[0] &#x3D; z[0]; z_f[1] &#x3D; z[2]; z_f[2] &#x3D; z[3];</span><br><span class="line"></span><br><span class="line">  Len[0] &#x3D; sqrt(pow((x_f[1] - x_f[0]), 2.0) + pow((y_f[1] - y_f[0]), 2.0) + pow((z_f[1] - z_f[0]), 2.0));</span><br><span class="line">  Len[1] &#x3D; sqrt(pow((x_f[2] - x_f[1]), 2.0) + pow((y_f[2] - y_f[1]), 2.0) + pow((z_f[2] - z_f[1]), 2.0));</span><br><span class="line">  Len[2] &#x3D; sqrt(pow((x_f[2] - x_f[0]), 2.0) + pow((y_f[2] - y_f[0]), 2.0) + pow((z_f[2] - z_f[0]), 2.0));</span><br><span class="line"></span><br><span class="line">   Area[3] &#x3D; sqrt((Len[0] + Len[1] + Len[2])*(Len[0] + Len[1] - Len[2])*(Len[0] + Len[2] - Len[1])*</span><br><span class="line">     (Len[1] + Len[2] - Len[0])) &#x2F; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;设\(f_1\left( \boldsymbol{x} \right) \)和\(f_2\left( \boldsymbol</summary>
      
    
    
    
    <category term="数值方法" scheme="http://example.com/categories/%E6%95%B0%E5%80%BC%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="高斯积分" scheme="http://example.com/tags/%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>连续/离散周期信号的傅里叶变换</title>
    <link href="http://example.com/2021/07/25/210725_DTFT_and_FFT/"/>
    <id>http://example.com/2021/07/25/210725_DTFT_and_FFT/</id>
    <published>2021-07-24T16:00:00.000Z</published>
    <updated>2021-07-25T15:17:50.426Z</updated>
    
    <content type="html"><![CDATA[<p>在信号处理中，傅里叶变换是必不可缺的一部分，而傅里叶变换又分为连续和非连续信号的傅里叶变换，现就这一系列的知识作一个总结和归纳。<a id="more"></a></p><h2 id="连续时间周期信号的傅里叶级数表示"><a href="#连续时间周期信号的傅里叶级数表示" class="headerlink" title="连续时间周期信号的傅里叶级数表示"></a>连续时间周期信号的傅里叶级数表示</h2><h3 id="成谐波关系的复指数信号集"><a href="#成谐波关系的复指数信号集" class="headerlink" title="成谐波关系的复指数信号集"></a>成谐波关系的复指数信号集</h3><p>如果一个信号是周期的，那么对于所有的\(t\)，存在某个正值的\(T\)，有：</p><div>$$x\left( t \right) =x\left( t+T \right) $$</div><p>\(x\left(t\right)\)的基波周期就是满足上式的最小非零正值\(T\)，\(\omega _0=2\pi /T\)称为基波频率。例如周期复指数信号</p><div>$$x\left( t \right) =e^{j\omega _0t}$$</div><p>与其有关的<strong>成谐波关系的复指数信号集</strong>就是</p><div>$$\phi _k\left( t \right) =e^{jk\omega _0t}=e^{jk\left( 2\pi /T \right) t}, k=0,\pm 1,\pm 2,...$$</div><p>这些信号中的每一个都有一个基波频率，是\(\omega_0\)的倍数，因此每一个信号对于周期\(T\)来说都是周期的。于是，一个由成谐波关系的复指数线性组合形成的信号</p><div>$$x\left( t \right) =\sum_{k=-\infty}^{+\infty}{a_ke^{jk\omega _0t}}=\sum_{k=-\infty}^{+\infty}{a_ke^{jk\left( 2\pi /T \right) t}}$$</div><p>对\(T\)来说也是周期的，上式中，\(k=0\)这一项是常数，\(k=+1\)和\(k=-1\)这两项都有基波频率等于\(\omega_0\)，两者结合在一起称之为基波分量，或者一次谐波分量。\(k=+2\)和\(k=-2\)这两项也是周期的，周期为基波分量周期的1/2，称之为二次谐波分量，依此类推。一个周期信号表示成上式，就称之为该式的<strong>傅里叶级数表示</strong>。</p><h3 id="傅里叶级数表示的确定"><a href="#傅里叶级数表示的确定" class="headerlink" title="傅里叶级数表示的确定"></a>傅里叶级数表示的确定</h3><p>现在假设一个给定的周期信号能表示成傅里叶级数的形式，那就需要一种方法来确定这些系数\(a_k\)。推导过程很简单，将上面的式子两边各乘以\(e^{-jn\omega _0t}\)并在\(0\)到\(T=2\pi /\omega _0\)上对\(t\)积分即可，有：</p><div>$$\int_0^T{x\left( t \right) e^{-jn\omega _0t}dt}=\int_0^T{\sum_{k=-\infty}^{+\infty}{a_ke^{jk\omega _0t}e^{-jn\omega _0t}}dt}\\=\sum_{k=-\infty}^{+\infty}{a_k\left[ \int_0^T{e^{j\left( k-n \right) \omega _0t}dt} \right]}$$</div>上式右边括号的积分结果利用欧拉关系很容易得到<div>$$\int_0^T{e^{j\left( k-n \right) \omega _0t}dt}=\begin{cases}    T, k=n\\    0, k\ne n\\\end{cases}$$</div><p>因此，右边的式子就简化为\(Ta_n\)，所以</p><div>$$a_n=\frac{1}{T}\int_0^T{x\left( t \right) e^{-jn\omega _0t}dt}$$</div><p>至此，周期函数的傅里叶级数展开的系数就确定了。另外，由于积分是在\(T\)的时间间隔内进行的，而\(T\)又是\(\cos \left( k-n \right) \omega _0t\)和\(\sin \left( k-n \right) \omega _0t\)周期的整数倍，所以在任意\(T\)的间隔做积分，结果都是相同的。</p><p>上述过程可以归纳如下：如果\(x\left( t \right)\)有一个傅里叶级数表示式，那么傅里叶级数中的系数可以确定为</p><div>$$x\left( t \right) =\sum_{k=-\infty}^{+\infty}{a_ke^{jk\omega _0t}}=\sum_{k=-\infty}^{+\infty}{a_ke^{jk\left( 2\pi /T \right) t}}\\a_k=\frac{1}{T}\int_T{x\left( t \right) e^{-jk\omega _0t}dt}=\frac{1}{T}\int_T{x\left( t \right) e^{-jk\left( 2\pi /T \right) t}dt}$$</div><h2 id="离散时间周期信号的傅里叶级数表示"><a href="#离散时间周期信号的傅里叶级数表示" class="headerlink" title="离散时间周期信号的傅里叶级数表示"></a>离散时间周期信号的傅里叶级数表示</h2><h3 id="成谐波关系的复指数信号集-1"><a href="#成谐波关系的复指数信号集-1" class="headerlink" title="成谐波关系的复指数信号集"></a>成谐波关系的复指数信号集</h3><p>对于一个离散信号\(x[n]\)，若有</p><div>$$x\left[ n \right] =x\left[ n+N \right] $$</div><p>就是一个周期为\(N\)的周期信号。基波周期就是\(N\)，基波频率为\(\omega _0=2\pi /N\)。例如，复指数\(e^{jk\left( 2\pi /N \right) n}\)就是周期的，再者，有下式给出的</p><div>$$\phi _k\left[ n \right] =e^{jk\omega _0n}=e^{jk\left( 2\pi /N \right) n},k=0,\pm 1,\pm 2,...$$</div><p>所有离散时间复指数信号集合都是周期的，且周期为\(N\)。\(\phi _k\left[ n \right]\)中的全部信号，其基波频率都是\(2\pi /N\)的整数倍，因此它们之间互为谐波关系。由于上式中的信号集只有\(N\)个信号是不相同的，因此不难得出</p><div>$$\phi _k\left[ n \right] =\phi _{k+rN}\left[ n \right] $$</div><p>现在我们希望利用序列\(\phi _k\left[ n \right]\)的线性组合来表示更为一般的周期序列，即</p><div>$$x\left[ n \right] =\sum_k{a_k\phi _k\left[ n \right]}=\sum_k{a_ke^{jk\omega _0n}}=\sum_k{a_ke^{jk\left( 2\pi /N \right) n}}$$</div><p>因为序列\(\phi _k\left[ n \right]\)只在\(k\)的\(N\)个相继值的区间上是不同的，因此上式求和仅仅需要包含\(N\)项即可，于是上式的求和可以写成</p><div>$$x\left[ n \right] =\sum_{k=\left< N \right>}{a_k\phi _k\left[ n \right]}=\sum_{k=\left< N \right>}{a_ke^{jk\omega _0n}}=\sum_{k=\left< N \right>}{a_ke^{jk\left( 2\pi /N \right) n}}$$</div><p>上式称之为<strong>离散时间傅里叶级数</strong>，而系数\(a_k\)称之为<strong>傅里叶级数系</strong>数。</p><h3 id="傅里叶级数表示的确定-1"><a href="#傅里叶级数表示的确定-1" class="headerlink" title="傅里叶级数表示的确定"></a>傅里叶级数表示的确定</h3><p>推导过程省去，直接给出离散时间傅里叶级数对，为</p><div>$$x\left[ n \right] =\sum_{k=\left< N \right>}{a_ke^{jk\omega _0n}}=\sum_{k=\left< N \right>}{a_ke^{jk\left( 2\pi /N \right) n}}\\a_k=\frac{1}{N}\sum_{n=\left< N \right>}{x\left[ n \right] e^{-jk\omega _0n}}=\frac{1}{N}\sum_{n=\left< N \right>}{x\left[ n \right] e^{-jk\left( 2\pi /N \right) n}}$$</div><p>上面的两个表明了，如果一个离散的周期信号展开为傅里叶级数的求法，第一个公式称之为<strong>综合公式</strong>，第二个称之为<strong>分析公式</strong>。和连续时间信号情况一样，离散时间傅里叶级数系数\(a_k\)也往往称之为\(x\left[ n \right] \)的<strong>频谱系数</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在信号处理中，傅里叶变换是必不可缺的一部分，而傅里叶变换又分为连续和非连续信号的傅里叶变换，现就这一系列的知识作一个总结和归纳。</summary>
    
    
    
    <category term="信号处理" scheme="http://example.com/categories/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
    <category term="傅里叶变换" scheme="http://example.com/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>微波网络中的分贝值</title>
    <link href="http://example.com/2021/07/18/210718_em_power_dB/"/>
    <id>http://example.com/2021/07/18/210718_em_power_dB/</id>
    <published>2021-07-17T16:00:00.000Z</published>
    <updated>2021-07-25T02:59:22.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们在仿真天线或者一些微波器件的时候，S参数是很重要的参数之一，关于S参数的定义在很多微波工程中的书都能找到，但是对于具体如何计算，却很少有教科书会提及，这些概念大多散落在CEM领域的一些专业论文里面。本文旨在介绍几种常用激励端口下的S参数提取。<a id="more"></a></p><h2 id="关于分贝值-dB"><a href="#关于分贝值-dB" class="headerlink" title="关于分贝值(dB)"></a>关于分贝值(dB)</h2><p>通常我们在商业软件中计算出来的S参数都是用dB值来表示，这是由于在微波系统中两功率电平P1和P2之比经常用分贝(dB)来表示，即</p><div>$$10\log _{10}\frac{P_1}{P_2}\mathrm{dB}$$</div>不难发现用这种定义方法后，当功率之比为2时等效为3dB，功率比为0.1时等效为-10dB。这使得在计算元器件之前的功率损耗和增益中变得容易，因为相乘的损耗或增益因子可以通过对每一级用分贝表示的损耗或增益的相加来计算。例如，当一个信号经过一个6dB的衰减器和一个23dB的放大器之后，将具有23-6=17dB的总增益。<p>值得注意的是，在微波网络中分贝值只表示为功率比，但有时候也可以用电压来表示功率比，由于 \( P_1=V_{1}^{2}R_1\) 和\(P_2=V_{2}^{2}R_2\)，因此有</p><div>$$10\log _{10}\frac{V_{1}^{2}R_2}{V_{2}^{2}R_1}=20\log \frac{V_1}{V_2}\sqrt{\frac{R_2}{R_1}}\mathrm{dB}$$</div><p>其中，\(R_1\)和\(R_2\)为负载电阻，\(V_1\)和\(V_2\)为负载电压，如果负载电阻相等，那么公式可以简化为</p><div>$$20\log \frac{V_1}{V_2}\mathrm{dB}$$</div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;当我们在仿真天线或者一些微波器件的时候，S参数是很重要的参数之一，关于S参数的定义在很多微波工程中的书都能找到，但是对于具体如何计算，却很少有教科书会提及，这些概念大多散落在CEM领域的一些专业论文里面。本文旨在介绍几种常用激励端口下的S参数提取。</summary>
    
    
    
    <category term="电磁场理论" scheme="http://example.com/categories/%E7%94%B5%E7%A3%81%E5%9C%BA%E7%90%86%E8%AE%BA/"/>
    
    
    <category term="S参数" scheme="http://example.com/tags/S%E5%8F%82%E6%95%B0/"/>
    
    <category term="分贝dB" scheme="http://example.com/tags/%E5%88%86%E8%B4%9DdB/"/>
    
  </entry>
  
  <entry>
    <title>光生写给结夏的信</title>
    <link href="http://example.com/2021/05/20/210520_letter_guangsheng_to_jiexia/"/>
    <id>http://example.com/2021/05/20/210520_letter_guangsheng_to_jiexia/</id>
    <published>2021-05-19T16:00:00.000Z</published>
    <updated>2021-05-20T05:57:40.916Z</updated>
    
    <content type="html"><![CDATA[<p>最近看完了日剧《最完美的离婚》，没想到在特别篇的结尾，光生和结夏还是分手了。</p><p>很久之后，光生写下了这样一封信给结夏。看完信被深切感动到了。</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27571309&auto=0&height=66"></iframe><p>星野结夏小姐：</p><p>春寒料峭，你是否安好？没有感冒吧？没有长冻疮吧？对不起，突然给你写信。如果能承蒙你在寒夜中雅鉴，不胜荣幸。</p><p>首先，向你报告，在我们家即将迎来第三个年头的两只猫的情况。不知为何，它们最近经常看电视，边看股票的新闻边交谈。对它们的人生来说，股票有什么作用呢？</p><p>金鱼咖啡，因为姐姐要调养身体，最近继男姐夫在画咖啡拉花，画风独辟蹊径，经常有女性客人失望而归。</p><p>经由上原先生介绍，前几天终于见到了河合先生。我很震惊，河合先生是位希腊雕像一样的大帅哥。他伸手同我握手，说，“初次见面”，不知道能不能和他成为朋友。</p><p>在目黑川来来往往的人们，抬头看着樱花树，期待着开花时节，已经互相定下了赏花的约定，那个热闹的季节又要到来了。</p><p>昨天我梦到你了，梦见你抱着好多气球。你把无数个气球系在我和你的身上，我和你被气球带起，飞上了天空。俯瞰着目黑川，发现玛蒂尔达和八朔在抬头看着我们，上原夫妇抱着小婴儿朝我们招手。我只能被气球带着，随风飘荡，对自己的无力有点悲伤。</p><p>我现在依然每天会走过岸边的街道，不可思议的是，并不觉得自己是一个人。我依然每天都同你的记忆一起生活着。你经常在浴室里唱的歌，“静静地，静静地，握起你的手，握起你的手”，这样开头的歌，这样的场景。</p><p>想起深夜两个人出门借DVD的那一次，我和你注意到月亮已经变得好大，一时忘了出门的理由，在夜色中散起步来。在旧山手路买了烤红薯，掰成两半之后，发现大小相差悬殊，于是猜拳决定。吃着红薯，笑着，牵着手。我说要结婚，你的嘴巴被红薯塞得满满囔囔的，含糊不清地回答了我，这样的开始，这样的场景。</p><p>和你结婚后，我懂得了很多事。洗手台上并排着的牙刷，被窝中碰到的脚，不知何时消失掉的冰箱中的布丁，先下楼梯，和在你的后面上楼梯……恋爱总有一天会变成生活，生活会变成喜悦。穿错了女生袜子出门，发邮件来拜托我录的电视节目，抓背，做噩梦了就互相依偎，另一位父亲，另一位母亲，另一个家乡，家乡寄来的装在蜜柑箱子里的白菜，由生活演奏的音乐，在生活中互相传达的故事……这里还四处散落着，房间的角落里，电灯泡的里面，窗帘的缝隙里，还同以前一样留着。我如今也每天感受着从过去而来的你所留下的爱情。</p><p>我今天也会走过河边的街道，各自拥有的两个人一起生活过的回忆，住在我心中的你，闯进你世界的我，不可思议的，并不觉得变成了一个人。总有一天会觉得这样的想法太过愚蠢，却还是这样想着，在夜色中散步，猜拳决定，吃着烤红薯，笑着，牵着手，吃着满口的烤红薯，再说起同样的话。</p><p>我们在一起的话会很开心吧？一起慢慢变老吧？<br>可以嫁给我吗？</p><p>2014年2月8日</p><p>我在目黑川岸边的旧公寓，和两只猫一起，等待着春天的来临。 </p><p>日文原文：</p><p>星野　結夏さま：</p><p>暦（こよみ）の上に春は立ちながら厳しい寒さが続いておりますがいかがお過ごしですか？風邪などひいていませんか？霜焼（しもや）けなどしていませんか？突然の手紙ごめんなさい。まだまだ寒く長い夜のついでに目を通していただければ幸（さいわ）いです。</p><p>まずわが家に暮らして３年目を迎える２匹（ひき）の猫に関してお知らせします。彼らはなぜか最近テレビをよく見ます。株価のニュースを見ながら話をしています。彼らの人生に株価が何か作用（さよう）することがあるのでしょうか？</p><p>金魚（きんぎょ）カフェでは姉の体調もあって最近継男（つぐお）さんがラテアートを描（か）いています。その絵の作風（さくふう）が常軌（じょうき）を逸（いっ）しており女性客が悲鳴（ひめい）を上げて帰ることしばしばです。</p><p>上原さんに紹介されて先日ついに河合さんと対面しました。驚きです。河合さんはまるでギリシャ彫刻（ちょうこく）のような二枚目だったのです。握手の手を差し伸べ「やあ、初めまして」とおっしゃっていました。友達になれるかどうかはちょっと分かりません。</p><p>目黒川を行き交（か）う人々は桜の木を見上げて開花（かいか）の時季（じき）を待ちわびながら、すでに花見の約束を取り交わしています。また、あのにぎやかな季節が訪（おとず）れるのですね！</p><p>昨日、君の夢を見ました。君がたくさんの風船（ふうせん）を抱（かか）えてくる夢でした。君は無数（むすう）の風船を僕と自分の体に結（むす）び付けました。僕と君は風船に軽く体を持ち上げられて空を飛びました。目黒川を見下ろすとマチルダとはっさくが見上げてるのが見えました。上原さんたちが赤ん坊を抱いて手を振っていました。僕は風に流されて飛んでいくしかない、自分の非力さが少し悲しかったです。</p><p>川沿（ぞ）いの道を今日も歩きます。不思議と一人になった気がしません。まだまだ僕は毎日を君の記憶と共に暮らしています。君がよくお風呂場で歌っていた歌、「静かに　静かに　手を取り　手を取り」、そんなふうに始まる歌、そんな光景。</p><p>深夜二人でDVDを借りに出掛けたときのこと、月がずいぶんと大きなことに気がついた僕と君は、そもそもなぜ出掛けたのかさえ忘れて、夜中の散歩をしました。旧山手通りで焼き芋（いも）を買って、半分に割ったら大きさがまるで違って、じゃんけんして食べて、笑って、手をつないで、僕が結婚を口にしたら、君は焼き芋いっぱい頬張（ほおば）った口で声にならない返事をしました。そんな始まり、そんな光景。</p><p>君と結婚して知ったことがあります。洗面台（せんめんだい）に並んだ歯ブラシ、ベッドの中でぶつかる足、いつの間にか消えてる冷蔵庫のプリン、階段を先に下りること、階段を後から上がること、恋がいつしか日常に変わること、日常が喜びに変わること、間違えてはいて出掛けた女物の靴下、メールで頼まれる番組録画（ろくが）、背中をかくこと、怖い夢を見たら寄り添（そ）うこと、もう一人の父親、もう一人の母親、もう一つの古里、古里から届くミカン箱の中のハクサイ、日常が奏（かな）でる音楽、日常を伝え合うことの物語（ものがたり）．．．ここにはまだそれが転がっています。部屋の隅に電球の裏にカーテンの隙間（すきま）にくっついたまま。僕は今も毎日のように過去から訪れる君の愛情を受け取っています。</p><p>川沿いの道を今日も歩きます。一人ずつ二人で生きていたこと、僕の中に住んでいる君、君の中に迷い込んだ僕、不思議と一人になった気がしません。いつかまたそう思うことの愚（おろ）かさを思いながらそれでも思います。夜中の散歩をして、じゃんけんして、食べて、笑って、手をつないで、焼き芋頬張りながら、また同じことを話すんです。</p><p>僕たち一緒にいると、楽しいよね？一緒に年を取りませんか？<br>結婚してくれませんか？</p><p>２０１４年２月８日</p><p>目黒川沿いの古いマンションで２匹の猫と共に春の訪れを待っています。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近看完了日剧《最完美的离婚》，没想到在特别篇的结尾，光生和结夏还是分手了。&lt;/p&gt;
&lt;p&gt;很久之后，光生写下了这样一封信给结夏。看完信被深切感动到了。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="最完美的离婚" scheme="http://example.com/tags/%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84%E7%A6%BB%E5%A9%9A/"/>
    
  </entry>
  
  <entry>
    <title>《少年维特的烦恼》读书笔记</title>
    <link href="http://example.com/2021/05/05/210505_The_Sorrows_of_Young_Werther/"/>
    <id>http://example.com/2021/05/05/210505_The_Sorrows_of_Young_Werther/</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-05-05T14:24:38.929Z</updated>
    
    <content type="html"><![CDATA[<p>五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。<a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=316000&auto=1&height=66"></iframe><p>故事中维特为了逃避世事的纷扰，只身来到瓦尔海姆。在一次去乡村舞会的路上，他结识了天使般美丽纯洁的少女夏绿蒂，并对她一见倾心，陷入爱河。这时的绿蒂已经和一个名叫阿尔伯特的人订了婚，阿尔伯特为人正直、诚实、可靠，就连绿蒂也认为：阿尔伯特的“稳重可靠仿佛天生可以作为一种基础，好让一个贤淑的女子在上面建立幸福的生活”。面对看起来如此般配的一对人，维特对绿蒂的爱情烈火并没有就此熄灭，而是越来越旺，维特几乎不能自己。一面是自己深爱的女子，一面是对自己友善的阿尔伯特——她的未婚夫，在三个人的爱情角逐中，维特经过矛盾和痛苦挣扎后不得不忍痛退出，去了一家很远的公使馆担任书记官，然而这里的生活并不如意，他常常郁郁寡欢，彷徨苦闷。最后他又回到了绿蒂身边，这时的绿蒂已经和阿尔伯特结婚，婚后的生活并不愉快。失去维特后，绿蒂的内心空虚寂寥，和维特的久别重逢，使他们再一次陷入爱情的深潭，不可自拔。维特对绿蒂的爱之深切与不能得到绿蒂的矛盾，又使他陷入绝望的境地，极度痛苦的维特最后举枪自杀。</p><p>对于维特最后的选择令我感到心痛，但又理解他的选择。美剧《无耻之徒》里面有一句台词：</p><blockquote><p>Love is not supposed to be cute, love is raw and destructive.<br>爱从来都不是什么可爱的东西，爱是生猛而具有毁灭性的。</p></blockquote><p>维特曾是那么地热爱着自然：</p><blockquote><p>每当我周围的可爱峡谷霞气蒸腾，杲杲的太阳悬挂在林梢，将它的光芒这儿那儿地偷射进幽暗密林的圣地中来时，我便躺卧在飞泉侧畔的茂草里，紧贴地面观察那千百种小草，感觉到叶茎间有个扰攘的小小世界——这数不尽也说不清的形形色色的小虫子、小蛾子——离我的心更近了，于是我感受到按自身模样创造我们的全能的上帝存在，感受到将我们托付于永痕欢乐海洋之中的博爱天父的嘘息。——五月十日</p></blockquote><p>和那么地喜欢着孩子们：</p><blockquote><p>是的，威廉，在这个世界上离我的心最近的是孩子们。每当我从旁边观察他们，从细小的事情中发现他们有朝一日所需要的种种品德与才能的萌芽，从他们今日的固执任性中看出将来的坚毅与刚强，从今日的顽皮放肆中看出将来的幽默乐观以及轻松愉快地应付人世危难的本领，每当我发现这一切还丝毫未经败坏，完整无损，我便一次一次地，反反复复地，吟味人类的导师[1]这句金言。——六月二十九日</p><p>注释：[1]指耶稣。事见《圣经·新约·马太福音》第十八章：耶稣对门徒说：”你们若不回转，变成小孩子的样子，断不得进天国。“</p></blockquote><p>每当我在书中读到维特在自然界中感受到美妙之处，以及和孩子们相处时的快乐，便会联想到自己也是那么地喜欢着大自然和孩子们，很多次走在家乡的田野里，小河边，独自寻觅着路边的野花，静静地聆听潺潺的水流声，和孩子们一起分享食物，教他们使用电脑，给他们布置玩耍的场地，从他们的热情和善良中感受到这个世界的可爱。</p><p>歌德完成这部作品前后只花了四周的时间，之所以能如此高效是因为这部作品中的大部分内容都来自歌德自身的经历。1772年5月，歌德遵循父命到威茨拉尔的帝国高等法院实习。威茨拉尔是座空气陈腐得令人窒息的小城，帝国法院更以办事拖沓而恶名远播。歌德因此把实习的事情抛到脑后，终日悠游于景色宜人的乡间，在那儿研读荷马、品达等人的作品，做他感兴趣的事情。6月9日，在一次乡村舞会上，他结识了天真美丽的少女夏绿蒂·布甫，对她产生了热烈的爱慕。但夏绿蒂已经订婚。尽管她的未婚夫科斯特纳和夏绿蒂一家对歌德都十分友善，但他仍因失恋而感到痛苦，终于在9月11日不辞而别，回到法兰克福。</p><p>回到故乡以后，歌德久久未能克服心头的苦闷，以致产生了自杀的念头。谁料差不多就在这个时候，另一个人却把他几经尝试而放弃的事情完成了，一个他认识的叫耶鲁撒冷的青年自杀了。出事地点也正好在威茨拉尔，歌德在散步时还常常与他相遇。而且自杀的主要原因也同为恋慕他人之妻遭到拒斥。这种种情况，不能不令歌德联想到自身的遭遇，对同病相怜的耶鲁撒冷的不幸感到切肤之痛。</p><p>再后来，1774年初，女作家索菲的女儿玛克西米莲娜嫁给了一个名叫勃伦塔诺的富商，移居到了法兰克福。前年，歌德从威茨拉尔返回故乡时，曾顺便访问她家，对她颇有好感。如今重逢，两人都甚为欣喜。可惜这幸福很快变成了新的痛苦源泉，勃伦塔诺比玛克西米莲娜大二十岁，已经时有五个孩子的鳏夫，除去做生意赚钱别无所长，性情急躁而好嫉妒，很快对两个年轻人的交往产生疑忌，以致和歌德产生激烈冲突。这新的痛苦狠狠触动了歌德心灵中旧有的创伤，使他感到更加痛苦。为了彻底医治好自己的伤痛，歌德便愤而提笔，开始了维特的写作。</p><p>年轻的歌德完全进入了创作的狂热和忘我地境地，就像个梦游者似的，在几乎是无意识的状态下写成了这本小册子，以致当他最后拿起手稿来进行修改润饰时，自己也感到十分惊讶。维特一书之所以能如此情真意切，感人肺腑，这都是因为歌德的亲身感受。</p><p>在信息发达的现代社会，经常能看见新闻有人因为各种原因而结束自己的生命，有时候很难去体会当事者要经历多大的痛苦，才会选择直面死亡，以死亡来结束掉这一切。我知道，这种决定并不是一瞬间完成的，而是从出生到当下的一种经历的积分式结果。我不会也没有权力去指责他人的决定，但我仍会感到惋惜，或许只要再等一等，就能体会到这个世界的一点点美好之处，而放弃结束生命的念头。</p><p>生命的意义是什么？我时常思考这个问题，但每个阶段得到的答案都不尽相同。现在的我觉得生命的意义在于爱，这种爱是对世间万物的爱，对他人的爱。一个人如果只考虑自身的利益，会很容易让自己陷入到一种狭隘的境地，无法去体会世界的美好和可爱之处。我们要去爱他人，去帮助他人，在爱人的过程中感受到被爱，从而建立人与人之间的羁绊。维系着我们生活下去的，正是这一份一份的羁绊。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;五一假期抽空把歌德的《少年维特的烦恼》读完了，最开始想读这本书还是因为青峰写给杨丞琳的一首同名歌，很喜欢青峰写的词，所以想要更深入地了解这首歌的含义。</summary>
    
    
    
    <category term="读书笔记" scheme="http://example.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="少年维特的烦恼" scheme="http://example.com/tags/%E5%B0%91%E5%B9%B4%E7%BB%B4%E7%89%B9%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::bind用法总结</title>
    <link href="http://example.com/2021/04/28/210428_cpp_std_bind/"/>
    <id>http://example.com/2021/04/28/210428_cpp_std_bind/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-05T08:48:59.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>std::bind</code>包含在标准库头文件<code>#include&lt;functional&gt;</code>中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。<a id="more"></a></p><h2 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h2><p> <code>std::bind</code>使用的一般形式： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, arg_list);</span><br></pre></td></tr></table></figure><p> 其中<code>fun</code>是一个函数，<code>arg_list</code>是用逗号隔开的参数列表。调用<code>new_fun()</code>相当于调用<code>fun(arg_list)</code>。 </p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="用法一：改变参数的个数"><a href="#用法一：改变参数的个数" class="headerlink" title="用法一：改变参数的个数"></a>用法一：改变参数的个数</h3><p>头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders; </span><br></pre></td></tr></table></figure><p>现在定义一个函数，接收一个数组<code>array</code>，数组长度<code>n</code>和某个数<code>num</code>，它将实现打印数组中大于<code>num</code>的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fun = [](<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> num)&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; num)  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>[i] &lt;&lt; ends;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>利用<code>std::bind</code>函数将原来函数调用所需要的参数固定为2个，实现过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span> &#125;;  </span><br><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, _1, _2, <span class="number">5</span>); <span class="comment">//_1，_2是占位符，固定num=5 </span></span><br><span class="line">new_fun(<span class="built_in">array</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(*<span class="built_in">array</span>)); <span class="comment">// 调用只需要2个参数了</span></span><br></pre></td></tr></table></figure><p>上面代码中_1，_2是占位符，定义于命名空间<code>placeholders</code>中，_1是n<code>new_fun</code>的第一个参数，_2是<code>new_fun</code>的第二个参数，以此类推。在本例中，<code>fun()</code>的调用需要传递三个参数，而用<code>bind()</code>进行绑定后只需两个参数了，因为第三个参数在绑定时被固定了下来。减少函数参数的调用，这是<code>bind</code>最常见的用法。</p><h3 id="用法二：更改参数的顺序"><a href="#用法二：更改参数的顺序" class="headerlink" title="用法二：更改参数的顺序"></a>用法二：更改参数的顺序</h3><p> <code>bind</code>的另一个常见的用法是更改参数的调用顺序，如 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> new_fun = bind(fun, _2, _1);</span><br></pre></td></tr></table></figure><p> 此时，调用<code>new_fun(1, 2)</code>相当于调用<code>fun(2, 1)</code>。 </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;std::bind&lt;/code&gt;包含在标准库头文件&lt;code&gt;#include&amp;lt;functional&amp;gt;&lt;/code&gt;中，它是一种函数适配器，接收一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="std::bind" scheme="http://example.com/tags/std-bind/"/>
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>C++中的std::function用法总结</title>
    <link href="http://example.com/2021/04/28/210428_cpp_std_function/"/>
    <id>http://example.com/2021/04/28/210428_cpp_std_function/</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-05-05T08:49:04.996Z</updated>
    
    <content type="html"><![CDATA[<p>关于标准库中的<code>std::function</code>类模板，在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>官方给出的解释是</p><blockquote><p>Class template <code>std::function</code> is a general-purpose polymorphic function wrapper. Instances of <code>std::function</code> can store, copy, and invoke any <code>CopyConstructible</code> <code>Callable</code> target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.</p></blockquote><a id="more"></a><p>中文的意思是：类模板<code>std::function</code>是一种通用的多态函数封装，<code>std::function</code>的实例可以对任何<code>CopyConstructible Callable</code><strong>目标</strong>进行存储、复制和调用操作，这些<strong>目标</strong>可以是普通函数、Lambda表达式、bind表达式，或者其它函数对象，和指向成员函数的指针和指向数据成员的指针。<code>std::function</code>对象可以看成是对C++中现有的可调用实体的一种类型安全的包裹（例如，函数指针这类可调用的实体，就是类型不安全的）。</p><p>比较通俗的理解就是，通过<code>std::function</code>对C++中各种可调用实体（普通函数、Lambda表达式、函数指针、以及其它函数对象等）的封装，可以形成一个新的可调用的<code>std::function</code>对象，让我们不需要再纠结那么多的可调用实体。</p><h2 id="对函数的封装"><a href="#对函数的封装" class="headerlink" title="对函数的封装"></a>对函数的封装</h2><p>定义一个实现加法的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将其封装为一个function类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_add = add;</span><br></pre></td></tr></table></figure><p>用下面的方式对<code>f_add</code>实体对象进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_add(<span class="number">4</span>,<span class="number">5</span>); <span class="comment">// 结果将返回9</span></span><br></pre></td></tr></table></figure><h2 id="对函数类-结构体的封装"><a href="#对函数类-结构体的封装" class="headerlink" title="对函数类/结构体的封装"></a>对函数类/结构体的封装</h2><p>定义一个除法的结构体或者类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_div</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> a / b; </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将其封装为一个function对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_div = my_div();</span><br></pre></td></tr></table></figure><p>同样的，调用形式和上面的<code>f_add</code>一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = f_div(<span class="number">6</span>, <span class="number">2</span>); <span class="comment">// 执行完result结果为3</span></span><br></pre></td></tr></table></figure><h2 id="对Lambda表达式的封装"><a href="#对Lambda表达式的封装" class="headerlink" title="对Lambda表达式的封装"></a>对Lambda表达式的封装</h2><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>Lambda表达式是C++11加入的新特性，利用Lambda表达式可以方便地定义和创建匿名函数。</p><p>Lambda表达式的完整声明为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><p> 各项具体含义如下 </p><ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul><p>我们可以省略其中的某些成分声明成“不完整”的Lambda表达式，常见的几种如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了返回值类型，编译器可以自动推断。</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) &#123;function body&#125;</span><br><span class="line"><span class="comment">// 省略了参数列表，类似普通函数中的无参函数。</span></span><br><span class="line">[capture <span class="built_in">list</span>] &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>让我们来看个例子，现在假设我们有一个无序的<code>vector</code>变量，我们想用C++标准库中的<code>sort</code>函数对其进行排序，我们需要传入一个所谓的谓词函数，来指定排序规则，以往的做法是先声明一个谓词函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  a &lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>sort</code>函数，旧式的做法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(), cmp);<span class="comment">// myvec是一个int类型的无序变量</span></span><br></pre></td></tr></table></figure><p>现在可以方便地利用Lambda表达式来简化代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(myvec.begin(), myvec.end(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b)-&gt;<span class="keyword">bool</span> &#123;<span class="keyword">return</span> a &lt; b;&#125;);</span><br></pre></td></tr></table></figure><p>值得注意的是，我们需要根据不同场景来定义捕获外部变量的形式， 主要有以下几种：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[x, y…]</td><td>默认以值的形式捕获指定的多个外部变量（用逗号分隔）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><p>如果我们需要修改捕获变量，这时需要利用<code>mutable</code>关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [a]()<span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; ++a; &#125;; <span class="comment">// 执行完后a=101</span></span><br></pre></td></tr></table></figure><h3 id="封装Lambda表达式"><a href="#封装Lambda表达式" class="headerlink" title="封装Lambda表达式"></a>封装Lambda表达式</h3><p>现在回到function对象用法的讨论中，对于Lambda表达式，可以封装为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; f_mul = [](<span class="keyword">double</span> x, <span class="keyword">double</span> y) &#123; <span class="keyword">return</span> x * y; &#125;;</span><br></pre></td></tr></table></figure><h2 id="将函数作为参数"><a href="#将函数作为参数" class="headerlink" title="将函数作为参数"></a>将函数作为参数</h2><p>很多时候，我们希望能够将一个函数作为参数传入到另一个函数中进行调用，这个时候用<code>std::function</code>实现就很方便，例如实现一个计算器函数，它能接受两个参数和一个函数，在里面进行计算并返回计算的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">calculator</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="built_in">std</span>::function&lt;<span class="keyword">double</span>(<span class="keyword">double</span>, <span class="keyword">double</span>)&gt; fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将上面已经定义的<code>f_add</code>对象作为参数传入<code>calculator()</code>函数中，在内部进行调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> res = calculator(<span class="number">4</span>, <span class="number">5</span>, f_add);</span><br></pre></td></tr></table></figure><p>这样我们就实现了函数的回调。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上的例子，我们学会了如何使用标准库中的<code>std::function</code>模板类对函数对象进行封装，从而可以统一成一种形式的调用，在最后我们还学习了如何将<code>std::function</code>类作为函数的参数，来实现回调函数的功能。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于标准库中的&lt;code&gt;std::function&lt;/code&gt;类模板，在&lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/functional/function&quot;&gt;cppreference&lt;/a&gt;官方给出的解释是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Class template &lt;code&gt;std::function&lt;/code&gt; is a general-purpose polymorphic function wrapper. Instances of &lt;code&gt;std::function&lt;/code&gt; can store, copy, and invoke any &lt;code&gt;CopyConstructible&lt;/code&gt; &lt;code&gt;Callable&lt;/code&gt; target – functions, lambda expressions, bind expressions, or other function objects, as well as pointers to member functions and pointers to data members.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="编程基础" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="c++标准库" scheme="http://example.com/tags/c-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="std::function" scheme="http://example.com/tags/std-function/"/>
    
    <category term="lambda表达式" scheme="http://example.com/tags/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
</feed>
